<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Spring源码环境搭建_idea</title>
      <link href="/2020/07/20/Spring%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-idea/"/>
      <url>/2020/07/20/Spring%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-idea/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前提条件：安装Git和Gradle(也可以使用源码包里配置的版本，推荐使用自己安装的，方便执行命令)</p></blockquote><h2 id="源码下载-git-clone-git-github-com-SpringSource-Spring-framework-git"><a href="#源码下载-git-clone-git-github-com-SpringSource-Spring-framework-git" class="headerlink" title="[源码下载](git clone git://github.com/SpringSource/Spring-framework.git)"></a>[源码下载](git clone git://github.com/SpringSource/Spring-framework.git)</h2><p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200720221952.png" alt=""></p><h2 id="导入IDEA"><a href="#导入IDEA" class="headerlink" title="导入IDEA"></a>导入IDEA</h2><p>查看开源代码，首先是看它的README.md文件，它会告诉我们很多东西，这里可以看到，如果要导入IDEA集成开发环境，需要去看哪个文件操作:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200720222053.png" alt=""></p><p>打开文件”import-into-idea.md”可以看到如下几步：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200720222142.png" alt=""></p><p>按照提示的步骤即可导入:</p><ul><li>执行命令<code>./gradlew :spring-oxm:compileTestJava</code>，结果如下：</li></ul><p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200720223803.png" alt=""></p><ul><li>导入IntelliJ IDEA（File-&gt;New-&gt;Project from existing Sources-&gt;Navigate to directory-&gt;Select build.gradle）</li></ul><p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200720223915.png" alt=""></p><ul><li>点击【Open】等待下载依赖导入:</li></ul><p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200720224027.png" alt=""></p><p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200720230250.png" alt=""></p><ul><li>测试构建模块Spring-aop:</li></ul><p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200720230323.png" alt=""></p><p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200720230508.png" alt=""></p><p>好了，Spring源码环境搭建好了，有时间的话可以慢慢了解下Spring的关键技术如何实现了，努力做到知其所以然~</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ANTLR(一)</title>
      <link href="/2020/07/15/ANTLR(%E4%B8%80)/"/>
      <url>/2020/07/15/ANTLR(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.antlr.org" target="_blank" rel="noopener">ANTLR</a>是基于Java编写的，一款强大的语法分析器生成工具，可用于读取、处理、执行和翻译结构化文本或二进制文件。除了间接左递归，ANTLR 4几乎能处理任何语法。</p><h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><p>安装很简单，下载最新jar包即可，该jar包包含了运行ANTLR的工具和编译、执行ANTLR产生的识别程序所依赖的全部运行库，即ANTLR工具将语法文件转换成可以识别该语法文件所描述的语言的程序。</p><p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200715220716.png" alt=""></p><p>下载好后，还需配置CLASSPATH使得Java程序能找到ANTLR工具和运行库:<code>export CLASSPATH=&quot;.:/Users/linjk/Documents/usr/services/antlr-4.8-complete.jar:$CLASSPATH&quot;</code></p><p>在shell的rc文件配置别名，方便启动：<code>alias antlr4=&#39;java -jar /Users/linjk/Documents/usr/services/antlr-4.8-complete.jar&#39;</code>，配置调试工具: <code>alias grun=&#39;java org.antlr.v4.gui.TestRig&#39;</code></p><p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200715220953.png" alt=""></p><p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200715221051.png" alt=""></p><h2 id="入门体验"><a href="#入门体验" class="headerlink" title="入门体验"></a>入门体验</h2><p>为了简单，定义一个能识别类似hello world或hello jim的词组的语法：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200715221847.png" alt=""></p><p>接下来编译该语法文件：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200715222023.png" alt=""><br>提示不匹配，语法名字和文件名字应一致，修改一致后：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200715222204.png" alt=""></p><p>它生成了antlrHelloParser.java和antlrHelloLexer.java组成的、可以运行的语法识别程序。(这里还缺少一个main程序来触发语言识别过程)</p><p>然后编译生成class文件<code>javac -g *.java</code>，<code>grun antlrHello r -tokens</code>来运行：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200715223921.png" alt=""><br>运行后，输入hello world，然后ctrl+d来输入文件结束符，因为使用了选项<code>-r tokens</code>，所以上面打印出来全部的词法符号的列表。还可以导出语法分析树：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200715224424.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
          <category> ANTLR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ANTLR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenResty(二)-Nginx和Lua基础</title>
      <link href="/2020/07/09/OpenResty(%E4%BA%8C)-Nginx%E5%92%8CLua%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/07/09/OpenResty(%E4%BA%8C)-Nginx%E5%92%8CLua%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><blockquote><p><a href="http://nginx.org/en/docs/" target="_blank" rel="noopener">Nginx模块配置文档</a></p></blockquote><ul><li>能通过Lua代码解决的，<strong>不用</strong>Nginx的配置、变量和模块解决</li><li>Nginx支持的功能，OpenResty不一定支持，需要看版本号，它们的版本号保持一致的</li></ul><h3 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h3><pre class="mermaid">graph LR    Master进程 --> Worker进程1     subgraph 客户端连接        客户端1 --> Worker进程1        客户端2 --> Worker进程1    end    Master进程 --> Worker进程2    Master进程 --> Worker进程...    Master进程 --> Worker进程n</pre><p>Master进程不负责处理终端的请求，它只管理Worker进程，主要是接受管理员发送的信号量、监控Worker的运行状态。<br>Worker进程从Master进程<strong>fork</strong>出来的，彼此之间相互独立，互不影响。有多个worker进程时，其中一个Worker进程奔溃退出了，并不会影响其他Worker进程。</p><p>Nginx和OpenResty的<a href="https://github.com/openresty/lua-nginx-module#readme" target="_blank" rel="noopener">生命周期关系</a>：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200710002937.png" alt=""></p><h2 id="Lua"><a href="#Lua" class="headerlink" title="Lua"></a>Lua</h2>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> OpenResty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenResty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker安装MariaDB</title>
      <link href="/2020/07/08/Docker%E5%AE%89%E8%A3%85MariaDB/"/>
      <url>/2020/07/08/Docker%E5%AE%89%E8%A3%85MariaDB/</url>
      
        <content type="html"><![CDATA[<p>MariaDb在官网的Mac系统的pkg包居然是10.2版本的，最新都10.5.4了，只能在docker仓库里查找一下是否有官方包了:<code>docker search mariadb</code>，有，很好，下载最新版本: <code>docker pull mariadb:10.5.4</code></p><p>查看本地已有的所有镜像确认一下：<code>docker images</code>:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200709003233.png" alt=""></p><p>运行数据库前，首先创建数据目录:<br><code>mkdir -p /Users/linjk/Documents/docker/mariadb/data</code> </p><p>启动数据库服务: <code>docker run --name mariadb -p 3298:3306 -e MYSQL_ROOT_PASSWORD={root用户密码} -v /Users/linjk/Documents/docker/mariadb/data:/var/lib/mysql -d mariadb:10.5.4</code>，参数说明</p><table><thead><tr><th>参数名</th><th>参数说明</th></tr></thead><tbody><tr><td>–name</td><td>运行的容器的名称</td></tr><tr><td>-p</td><td>主机端口：容器端口的映射关系</td></tr><tr><td>-e</td><td>设置数据库root用户的密码</td></tr><tr><td>-v</td><td>数据卷映射</td></tr><tr><td>-d</td><td>后台运行容器的模式</td></tr></tbody></table><p>查看容器是否运行<code>docker ps -a</code>:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200709003808.png" alt=""></p><blockquote><p>如果需要容器在运行docker服务后自启动，可以配置：<code>docker container update --restart=always {容器id}</code><br>如果需要进入容器查看数据库更多信息，可以配置：<code>docker exec -it {容器Id} bash</code>，然后执行命令<code>mysql -uroot -proot密码</code>即可在容器内登录数据库。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> DB </category>
          
          <category> MariaDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MariaDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenResty(一)-入门</title>
      <link href="/2020/07/06/OpenResty(%E4%B8%80)-%E5%85%A5%E9%97%A8/"/>
      <url>/2020/07/06/OpenResty(%E4%B8%80)-%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/openresty/openresty.org" target="_blank" rel="noopener">OpenResty</a>诞生于2007年，是一个兼具开发效率和性能的服务端开发平台，其核心是基于Nginx的一个C模块(lua-nginx-module)，该模块将LuaJIT嵌入到Nginx服务器中，并对外提供了一套完整的Lua API，透明地支持非阻塞I/O，提供了轻量级线程、定时器等高级抽象。主要用来实现微服务API网关。</p><pre class="mermaid">graph LR;    OpenResty三大特性-->详尽的文档和测试用例;    OpenResty三大特性-->同步非阻塞;    OpenResty三大特性-->动态;</pre><blockquote><p>对于 OpenResty 来说，绝大部分都是同步操作，只有 ngx.timer 这种后台定时器相关的 API，才是异步操作</p></blockquote><h3 id="安装OpenResty"><a href="#安装OpenResty" class="headerlink" title="安装OpenResty"></a>安装OpenResty</h3><p><code>brew tap openresty/brew &amp;&amp; brew install openresty</code></p><blockquote><p>小插曲：<br>brew命令卡在<strong>Updating Homebrew…</strong><br>可以<code>Ctrl+C</code>取消下就可以了<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200707222135.png" alt="brew慢问题懒人解决方式"></p></blockquote><p>OK, 安装成功：<br><code>which resty &amp;&amp; resty -e &quot;ngx.say(&#39;【OpenResty】&#39;)&quot;</code></p><p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200707230630.png" alt="OpenResty安装成功"></p><p>安装信息：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200708002135.png" alt=""></p><blockquote><p>–prefix就是安装路径了</p></blockquote><h3 id="雏形"><a href="#雏形" class="headerlink" title="雏形"></a>雏形</h3><p>上面直接通过命令行的-e参数运行nginx服务的，现在，正式一点，在文件夹下通过配置文件配置方式，更接近实际：</p><p><a href="https://github.com/openresty/lua-nginx-module#content_by_lua_file" target="_blank" rel="noopener">更详细API参考</a></p><ul><li>准备目录结构</li></ul><p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200707231028.png" alt="目录"></p><ul><li>准备配置文件</li></ul><p><code>vim demo/conf/nginx.conf</code></p><p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200707231257.png" alt="nginx.conf"></p><ul><li>启动OpenResty服务</li></ul><p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200707231410.png" alt="OpenResty服务"><br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200707231446.png" alt="访问测试"></p><ul><li>退出服务</li></ul><p><code>openresty -p</code>pwd<code>-c demo/conf/nginx.conf -s quit</code></p><p>上面直接把代码放在配置文件，不合适，现在把它抽出来：</p><p><code>mkdir demo/lua &amp;&amp; echo &quot;ngx.say(&#39;openresty&#39;)&quot; &gt; demo/lua/openresty.lua &amp;&amp; cat demo/lua/openresty.lua</code></p><p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200708001505.png" alt=""></p><p>然后修改配置文件nginx.conf:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200708001638.png" alt=""></p><p>重启OpenResty服务，可以正常访问。</p><h3 id="寻求帮助"><a href="#寻求帮助" class="headerlink" title="寻求帮助"></a>寻求帮助</h3><p>可以借助OpenResty提供的命令<code>restydoc</code>，如：</p><blockquote><p>restydoc -s ngx.say<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200708002431.png" alt=""><br>这些文档的路径就是–prefix参数下的pod子文件夹</p></blockquote><h3 id="包管理工具"><a href="#包管理工具" class="headerlink" title="包管理工具"></a>包管理工具</h3><p><a href="http://opm.openresty.org" target="_blank" rel="noopener">OPM</a>是OpenResty自带的包管理器(<em>不支持私有包</em>)，类似docker search，opm也支持搜索:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200708003326.png" alt=""></p><p><a href="https://github.com/bungle/awesome-resty" target="_blank" rel="noopener">这里</a>维护了几乎所有OpenResty可用的包。</p><p><a href="https://luarocks.org" target="_blank" rel="noopener">luarockers</a>是推荐使用的包管理工具，安装步骤：</p><ul><li><p>wget <a href="https://luarocks.org/releases/luarocks-3.3.1.tar.gz" target="_blank" rel="noopener">https://luarocks.org/releases/luarocks-3.3.1.tar.gz</a></p></li><li><p>tar zxf luarocks-3.3.1.tar.gz</p></li><li><p>【需事先安装lua】cd luarocks-3.3.1 &amp;&amp; ./configure &amp;&amp; make &amp;&amp; sudo make install</p></li></ul><p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200708004213.png" alt=""></p><h3 id="OPM项目初探"><a href="#OPM项目初探" class="headerlink" title="OPM项目初探"></a>OPM项目初探</h3><p>通过官方的<a href="https://github.com/openresty/opm" target="_blank" rel="noopener">OPM项目</a>，了解OpenResty的基本开发的目录结构，有助于入门。透过这个项目，可以学习一个OpenResty项目是如何分层组织起来的。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> OpenResty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenResty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AboutMe</title>
      <link href="/2020/07/05/AboutMe/"/>
      <url>/2020/07/05/AboutMe/</url>
      
        <content type="html"><![CDATA[<p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/wechat.jpg" alt="微信公众号【时光记旅】"></p>]]></content>
      
      
      <categories>
          
          <category> Misc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Misc </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
