<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JVM入门</title>
      <link href="/2020/11/27/JVM%E5%85%A5%E9%97%A8/"/>
      <url>/2020/11/27/JVM%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>JVM是Java Virtual Machine的简称，即Java虚拟机，它使用软件模拟Java字节码的指令集，而类似VMWare的虚拟机是使用软件模拟物理CPU的指令集。</p><h3 id="Java语言规范"><a href="#Java语言规范" class="headerlink" title="Java语言规范"></a>Java语言规范</h3><ul><li><p>语法、词法</p><ul><li>If Then 语句格式</li><li>ArgumentList 参数列表</li><li>行终结符、空白符、注释、标识符、关键字</li></ul></li><li><p>变量</p><ul><li>初始值规则</li><li>泛型</li><li>基础类型</li></ul></li><li><p>类型</p></li><li><p>文法</p></li><li><p>内存模型</p></li><li><p>类加载链接过程</p></li><li><p>异常</p></li><li><p>……</p></li></ul><h3 id="JVM规范"><a href="#JVM规范" class="headerlink" title="JVM规范"></a>JVM规范</h3><p>主要定义二进制class文件和JVM指令集等。</p><ul><li>Class文件类型</li><li>运行时数据</li><li>栈帧、堆、方法区、PC</li><li>虚拟机的启动</li><li>虚拟机的指令集</li><li>JVM反汇编的格式</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GTest初探</title>
      <link href="/2020/11/24/GTest%E5%88%9D%E6%8E%A2/"/>
      <url>/2020/11/24/GTest%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<p>最近写些C++代码，发现在Java习惯了单元测试后，觉得还是有必要引入，GitHub搜了下，<a href="https://github.com/google/googletest/releases/tag/release-1.10.0" target="_blank" rel="noopener">找到</a>了，用下试试。</p><p>这里下载的1.10.0版本，下载解压后，使用cmake生成makefile文件，然后<code>make &amp;&amp; make install</code>搞定，如下：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20201124234115.png" alt=""></p><p>操刀试试吧~</p><ol><li>引入依赖<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20201124234322.png" alt=""></li><li>编写类的测试代码<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20201125003305.png" alt=""></li><li>运行<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20201125003414.png" alt=""></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> GTest </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GTest </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Boost入门</title>
      <link href="/2020/11/24/Boost%E5%85%A5%E9%97%A8/"/>
      <url>/2020/11/24/Boost%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.boost.org/" target="_blank" rel="noopener">Boost</a>是一个功能强大、构造精巧、跨平台、开源并且完全免费的C++程序库，现在有C++“准标准”库之称，使用C++而不用标准库，避免不了重复造轮子，但是，程序员不应该只满足于调用，也应该拥有造轮子的能力。因为编译MySQL5.7.19需要依赖boost1.59.0，所以，这里采用这个版本，可以到这里选择合适的版本<a href="https://www.boost.org/users/history/" target="_blank" rel="noopener">下载</a>，后面值得好好看一下boost的代码，里面很多设计值得参考借鉴。</p><p>下载后，解压到自己指定的目录即可：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20201124221115.png" alt=""></p><p>目录说明：</p><ul><li>boost: 源码</li><li>doc: 文档</li><li>libs: 所有组件的示例/测试/编译代码</li><li>more: 库作者相关的文档</li><li>status: 可用于测试的Boost库的各个组件</li><li>tools: b2等工具</li></ul><p>Boost库的使用很简单，各个解压后即可，后面的项目需要用到的话，直接在代码包含boost子目录下面对应模块的hpp代码即可，有些库如chrono、date_time等需要编译成静态库或动态库链接后才能使用，这个用到再说。</p><blockquote><p>Mac系统需要注解的参数<code>compiler.balcklist clang --with-toolset=clang</code>:</p><ol><li>./bootstrap.sh  –with-libraries=all compiler.balcklist clang –with-toolset=clang</li><li>./b2 –buildtype=complete install</li></ol></blockquote><p>编译安装<code>默认安装到/usr/local/bin和/usr/local/include目录下</code>，这里使用完全编译，将包含所有调试版、发行版的静态库和动态库：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20201124221638.png" alt=""></p><p>接下来，来测试使用下Boost:</p><ol><li>添加库头文件依赖<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20201124222410.png" alt=""></li><li>简单测试<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20201124222610.png" alt=""></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> Boost </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Boost </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter初探</title>
      <link href="/2020/11/22/Flutter%E5%88%9D%E6%8E%A2/"/>
      <url>/2020/11/22/Flutter%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<p><a href="https://flutter.dev/docs/get-started/install/macos" target="_blank" rel="noopener">Flutter</a>是谷歌的移动UI框架，可以快速在iOS和Android上构建高质量的原生用户界面。下载Flutter SDK后，解压到自定义的目录下并配置bin子目录到环境变量：</p><p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20201122215321.png" alt=""></p><p>增加环境变量:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20201122215439.png" alt=""></p><p>配置完成后，检测开发环境<code>flutter doctor</code>:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20201122220213.png" alt=""></p><p>环境配置好后，这里使用Android Studio创建一个开发项目，创建时选择创建Flutter项目一步步操作即可，完成后目录结构如下：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20201122220401.png" alt=""></p><p>后面连接Android设备打开开发者模式就可以进行调试了。</p>]]></content>
      
      
      <categories>
          
          <category> Frontend </category>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac系统打开JDGui后闪退问题解决</title>
      <link href="/2020/10/24/Mac%E7%B3%BB%E7%BB%9F%E6%89%93%E5%BC%80JDGui%E5%90%8E%E9%97%AA%E9%80%80%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
      <url>/2020/10/24/Mac%E7%B3%BB%E7%BB%9F%E6%89%93%E5%BC%80JDGui%E5%90%8E%E9%97%AA%E9%80%80%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<p>问题如题，系统版本如下：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20201024122315.png" alt=""></p><p>不知是不是同时安装了jdk9和jdk8的原因，打开jd-gui后界面没出现就闪退了，jd-gui在jdk8下面才可以运行，为了保证基于jdk8运行，修改软件的启动脚本：</p><p>1.右键，选择显示包内容<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20201024122332.png" alt=""></p><p>2.修改启动脚本<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20201024122409.png" alt=""></p><p>修改部分如下：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20201024122427.png" alt=""></p><p>增加这一行即可。</p><p>3.正常启动<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20201024122451.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Misc </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch学习(1)</title>
      <link href="/2020/10/24/ElasticSearch%E5%AD%A6%E4%B9%A0-1/"/>
      <url>/2020/10/24/ElasticSearch%E5%AD%A6%E4%B9%A0-1/</url>
      
        <content type="html"><![CDATA[<p>ElasticSearch是一款基于Lucene的功能强大的开源分布式搜索与数据分析引擎，它具有高性能、易于扩展的优点，不仅可以从海量数据中快速找到相关信息，还被广泛运用于大数据近实时的分析，包括日志分析、指标监控、信息安全等多个领域。</p><blockquote><p>相关链接：<br><a href="https://www.elastic.co/cn/products/elasticsearch" target="_blank" rel="noopener">ElasticSearch官网</a><br><a href="https://www.elastic.co/cn/blog" target="_blank" rel="noopener">Elastic公司技术博客</a><br><a href="http://www.elasticsearch.cn/" target="_blank" rel="noopener">Elastic中文社区</a></p></blockquote><p>常听的ELK，即ElasticSearch、Logstash、Kibana，可以搭建一个完整的数据采集、存储、可视化的平台，这里来先动手实践，对其流程有一个感官的理解，后面再慢慢去深入了解ElasticSearch的各种高级用法。</p><p>首先，需要下载ELK三件套，注意，这三者的版本必须一致，否则无法正常进行数据采集，我这里采用的是<strong>7.8.0</strong>版本的:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20201209000918.png" alt=""></p><p>另外还需要注意的是，安装之前需要JDK环境的支持，JAVA_HOME的配置很简单,这里就不多说了。</p><h2 id="安装ElasticSsearch"><a href="#安装ElasticSsearch" class="headerlink" title="安装ElasticSsearch"></a>安装ElasticSsearch</h2><p>下载ES压缩包，解压后目录结构如下所示：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20201209001024.png" alt=""></p><p>目录说明：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20201024120553.png" alt=""></p><h3 id="配置elasticsearch-yml"><a href="#配置elasticsearch-yml" class="headerlink" title="配置elasticsearch.yml"></a>配置elasticsearch.yml</h3><p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20201212012322.png" alt=""></p><h3 id="配置jvm-options"><a href="#配置jvm-options" class="headerlink" title="配置jvm.options"></a>配置jvm.options</h3><p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20201024120656.png" alt=""></p><p>还有一点要注意，上面的值设置不要超过30GB大小。</p><h3 id="启动elasticsearch"><a href="#启动elasticsearch" class="headerlink" title="启动elasticsearch"></a>启动elasticsearch</h3><p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20201212012729.png" alt=""></p><p>检查确认启动成功：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20201212012938.png" alt=""></p><p>注意这里，cluster_name，是ES集群的名称，默认名字为<code>elasticsearch</code>，这里只是单机的一个实例，单一个集群有多个节点时，需要确保集群名称一样，可以通过如下方式在本机启动一个集群的多个节点：</p><blockquote><p>./elasticsearch -E node.name=linjk_1 -E cluster.name=linjk-framework-test -E path.data=xxx -E http.port=9202 -d<br>./elasticsearch -E node.name=linjk_2 -E cluster.name=linjk-framework-test -E path.data=xxx -E http.port=9204 -d<br>./elasticsearch -E node.name=linjk_3 -E cluster.name=linjk-framework-test -E path.data=xxx -E http.port=9206 -d</p></blockquote><p>节点是一个Elasticsearch实例，本质是一个Java进程，每个节点启动后，会分配一个UID，保存在data目录下。</p><p> 然后可通过URL查看当前集群有多少个节点：<br> <img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20201212013149.png" alt=""></p><p> 为了后面方便，这里安装了IK中文分词器:</p><blockquote><p>elasticsearch-plugin.bat install <a href="https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.8.0/elasticsearch-analysis-ik-7.8.0.zip" target="_blank" rel="noopener">https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.8.0/elasticsearch-analysis-ik-7.8.0.zip</a>   </p></blockquote><p> <img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20201024120928.png" alt=""></p><p> 安装完成后，<strong>重启ES</strong>，查看安装的插件：<br> <img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20201212013239.png" alt=""></p><h3 id="ES配置用户名密码"><a href="#ES配置用户名密码" class="headerlink" title="ES配置用户名密码"></a>ES配置用户名密码</h3><p> <img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20201024121001.png" alt=""></p><p> 提示需要配置X-Pack，配置如下：<br> <img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20201024121018.png" alt=""></p><p> <strong>重启ES</strong>，重新配置密码：(这里我都用了一个密码<code>ljk121</code>)<br> <img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20201024121040.png" alt=""></p><p> 这是再访问<a href="http://localhost:9200，就会弹出登录对话框了：">http://localhost:9200，就会弹出登录对话框了：</a><br> <img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20201024121100.png" alt=""></p><h2 id="安装Kibana"><a href="#安装Kibana" class="headerlink" title="安装Kibana"></a>安装Kibana</h2><p>上面是通过浏览器去调用ES提供的一些API，但是只能发GET请求，后面需要发POST请求去查询一些数据就不方便了，这里可以借助Kibana这个工具，启动Kibana很简单，修改其配置文件，然后执行bin目录下的bat或sh脚本即可，注意，ES首先需要启动，在这里ES是服务端，Kibana是客户端。</p><p>修改配置文件<code>kibana.yml</code>：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20201024121150.png" alt=""></p><p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20201024121136.png" alt=""></p><p>启动：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20201024121208.png" alt=""></p><p>验证：【<a href="http://localhost:5601】*注意：登录Kibana的账号信息和ElasticSearch的一样">http://localhost:5601】*注意：登录Kibana的账号信息和ElasticSearch的一样</a>*<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20201024121230.png" alt=""></p><p>圈住的Dev Tools很有用，如下所示：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20201024121249.png" alt=""></p><p>可以很方便运行ES提供的一些API函数。这里暂时就用到Kibana的Dev Tools，其他功能后面再慢慢探索。</p><h2 id="Docker安装es"><a href="#Docker安装es" class="headerlink" title="Docker安装es"></a>Docker安装es</h2><blockquote><p>扩展<br><a href="https://www.elastic.co/cn/blog/docker-networking" target="_blank" rel="noopener">设置Docker网络</a><br><a href="https://www.elastic.co/cn/blog/docker-networking" target="_blank" rel="noopener">Docker Image中安装插件</a><br><a href="https://github.com/lmenezes/cerebro" target="_blank" rel="noopener">Cerebro 源码</a><br><a href="https://docs.docker.com/compose/install/" target="_blank" rel="noopener">安装 docker-compose</a><br><a href="https://github.com/deviantony/docker-elk" target="_blank" rel="noopener">ELK docker-compose 配置</a></p></blockquote><p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20201212022024.png" alt=""></p><p>然后在该文件目录下执行命令<code>docker-compose up</code>即可同时启动elasticsearch和kibana了。</p><p>安装es集群监控工具：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20201212022608.png" alt=""></p><p>其监控页面如下：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20201212023340.png" alt=""></p><h2 id="安装Logstash"><a href="#安装Logstash" class="headerlink" title="安装Logstash"></a>安装Logstash</h2><p>有了存储数据的ES和可视化工具Kibana，现在就需要从数据库导入数据到ES了，这里从MySQL导入数据到ES，以借助ES强大的搜索和分析能力去进一步实现后面的业务功能。</p><p>新建一个测试库和测试表：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20201024121329.png" alt=""></p><p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20201024121343.png" alt=""></p><p>新建Logstash导入数据的配置文件:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20201024121516.png" alt=""></p><p>如ES开启了密码，hosts配置需要修改为：<a href="http://elastic:xxx@localhost:9200" target="_blank" rel="noopener">http://elastic:xxx@localhost:9200</a></p><p>编写后最好测试一下配置文件是否有语法问题：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20201024121540.png" alt=""></p><p>没问题，启动:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20201024121602.png" alt=""></p><p>报错：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20201024121619.png" alt=""></p><p>解决：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20201024121632.png" alt=""></p><p>下载安装插件：</p><p><a href="https://github.com/logstash-plugins/logstash-input-jdbc/releases/tag/v4.3.19" target="_blank" rel="noopener">https://github.com/logstash-plugins/logstash-input-jdbc/releases/tag/v4.3.19</a></p><p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20201024121657.png" alt=""></p><p>然后安装：(生成gem文件这一步需要先安装Ruby)<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20201024121724.png" alt=""></p><p>再次启动，可以看到，在执行数据同步了：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20201024121744.png" alt=""></p><p>去ES查询验证一下：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20201024121805.png" alt=""></p><p>可以看到，在ES可以看到了，接下来，在MySQL修改这条数据，看是否也能同步更新ES的数据，同步的时间最小粒度是1分钟，可以看到，数据也变化了。</p><p>这里使用一张表的数据，对应于一个索引的数据，数据库的每一条数据对应于索引的一个文档。Elasticsearch是面向文档的，文档是所有可搜索数据的最小单位，文档会被序列化成JSON格式存储，每个文档都有其UUID。</p><p>索引体现了逻辑空间的概念，每个索引一般都会有分片，而分片，体现的就是物理空间的概念，索引的mapping定义文档字段的类型，setting定义不同的数据分布。</p><p>好了，从采集数据到存储到ES的链路走通了，后面学习再慢慢研究使用ES了。</p>]]></content>
      
      
      <categories>
          
          <category> DB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows系统下不错的Shell软件Babun</title>
      <link href="/2020/09/27/Windows%E7%B3%BB%E7%BB%9F%E4%B8%8B%E4%B8%8D%E9%94%99%E7%9A%84Shell%E8%BD%AF%E4%BB%B6Babun/"/>
      <url>/2020/09/27/Windows%E7%B3%BB%E7%BB%9F%E4%B8%8B%E4%B8%8D%E9%94%99%E7%9A%84Shell%E8%BD%AF%E4%BB%B6Babun/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/babun/babun" target="_blank" rel="noopener">Babun</a>在GitHub上可以找到，它让习惯Linux系统的shell的开发人员可以在Windows系统下也有很好的命令行使用体验，虽然后Cygwin，但是，这个，不会让你失望。</p><p>简介：</p><ul><li>一键安装，不需要admin权限</li><li>类似包管理器apt-get/yum，它的包管理器为pact</li><li>集成oh-my-zsh</li><li>……</li></ul><p>下载后放到你需要安装到的目录，执行安装脚本即可：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200927205526.png" alt=""></p><p>等待安装：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200927205541.png" alt=""></p><p>安装完成：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200927205557.png" alt=""></p><p>可以右键文件夹直接进入：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200927205611.png" alt=""></p><p>用过mac系统的，一定很熟悉<code>open .</code>直接打开Finder吧，也可以哦：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200927205628.png" alt=""></p><p>接下来，在Windows上体验Linux吧。</p>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>高性能缓存系统Redis安装与使用</title>
      <link href="/2020/09/27/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E7%B3%BB%E7%BB%9FRedis%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/09/27/%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%93%E5%AD%98%E7%B3%BB%E7%BB%9FRedis%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>在互联网后台架构中，需要应付高并发访问数据库，很多时候都会在数据库上层增加一个缓存服务器来保存经常读写的数据以减少数据库压力，可以使用LVS、Memcached或Redis，Memcached和Redis是同样类型产品，但是Redis更好的地方是可以保存数据快照，在机器重启后，可以保存一部分数据，而Memcached会断电丢失数据，Redis还有如下有点：</p><ol><li>丰富的数据类型，如：string, hash, list, set, hyperloglog等</li><li>提供AOF和RDB两种数据持久化方式(持久化需要合理规划内存！！) RDB是Redis默认的持久化方式，默认数据文件是: dump.rdb</li><li>所有操作都是原子性的，支持事务</li></ol><p>下面来安装使用一下：</p><ol><li><p>[下载](wget <a href="http://download.redis.io/releases/redis-3.0.4.tar.gz" target="_blank" rel="noopener">http://download.redis.io/releases/redis-3.0.4.tar.gz</a>)</p></li><li><p>安装</p><blockquote><p>tar zxf redis-6.0.8.tar.gz<br>cd redis-6.0.8<br>yum install tcl - Linux需要执行，Mac不需要<br>make<br>make test<br>sudo make install<br>  <code>如提示pkg-config找不到，需要安装: brew install pkg-config</code></p></blockquote></li><li><p>配置<br> sudo cp redis.conf /etc/<br> sudo vim /etc/redis.conf —&gt; 修改这行为yes: daemonize yes，使Redis可以在后台运行</p></li><li><p>启动<br> <code>redis-server ~/Documents/usr/path-var/redis-6.0.8/conf/redis.conf</code></p></li><li><p>连接测试<br> <code>redis-cli -h 127.0.0.1 -p 6379</code><br> <img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200927204426.png" alt=""></p><p> 查看内存使用状况:<br> <img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200927204514.png" alt=""></p><ul><li><p>use_memory_human：返回Redis分配的内存总量</p></li><li><p>use_memory_rss: 从操作系统的角度，返回redis已分配的内存总量，与top命令输出结果一致</p></li><li><p>use_memory_peak：内存消耗峰值</p><blockquote><p>使用Python连接Redis:</p><ol><li>pip3 install redis</li><li><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200927205027.png" alt=""><br>读到的值，也是刚刚设置的结果</li></ol></blockquote></li></ul></li><li><p>完成<br> Redis数据类型说明：</p><ul><li>string: 存储简单的数据，可以接受任何格式的二进制数据，如JPEG图片或JSON字符串，最多可容纳数据长度为512MB。</li><li>hash: 接近数据库模型，value值是一个hashmap的结构</li><li>list: 按照插入顺序排序的字符串链表，可以被用作消息队列</li><li>set: 无序且不重复的元素集合</li><li>sorted set: 有序且不重复的元素集合，元素插入后就会自动排序，因此很适合开发需要排行榜类的应用　　</li></ul></li><li><p>扩展<br> 集群: 推荐使用Twitter开源的Twemproxy的Redis代理，原理：Redis客户端把请求发送到Twemproxy，Twemproxy根据路由规则发送到正确的Redis实例，最后Twemproxy把结果汇集返回给客户端。缺点：不支持平滑重启Redis实例，可以使用豌豆荚对其的改进软件: Codis。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> DB </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows编程基础</title>
      <link href="/2020/09/19/Windows%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/09/19/Windows%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>虽然现在有不少Windows平台的快捷开发语言和工具，如C#、Delphi、MFC等，但是，作为一个C语言出身的我，几年了，还是想偶尔回去看看底层原理，那就从Windows基础编程开始吧。</p><p>Windows编程，有一个很重要的理念就是：事件驱动，即实现以消息驱动为基础的应用程序，这个很重要，使用如上所述的几种语言，其实就是在写回调函数去实现自己的业务系统，以前学过，现在就纯粹记个笔记吧。</p><p>回过头来，一个Windows打开窗口的基本过程，想一下其实也不难，有如下几步：</p><ol><li>创建窗口</li><li>显示窗口</li><li>鼠标、键盘消息处理</li></ol><p>先来看一个基本的程序例子，创建一个win32的项目工程：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200919105510.png" alt=""></p><p>如果不勾选”Empty Project”而选择”Windows Application”，就会生成模板代码，如下：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200919105534.png" alt=""></p><p>main函数如下：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200919105704.png" alt=""></p><p>TranslateMessage函数是为了将键盘消息转化，DispatchMessage函数会将消息传给窗口函数去处理，注意到，DispatchMessage并没有指定窗口指针，它怎么知道传给哪个窗口？这是因为，消息发生时，操作系统已根据当时状态给这个消息指明了所属窗口，而窗口在创建时指定了回调函数的指针，因此，消息会有消费的地方，这一环节，会依赖于user.lib模块。</p><p>代码可以自己用ide生成，从代码来总结出Windows程序的生命周期如下：</p><ol><li><p>程序初始化过程中调用CreateWindow创建窗口，创建后会发出消息WM_CREATE给窗口函数，可以在响应这个消息的部分进行一些初始化操作；</p></li><li><p>窗口程序打开运行时，在while循环不断处理消息，如果收到消息WM_QUIT，GetMessage会返回0从而结束循环，然后退出程序；</p></li><li><p>当用户点击菜单的Exit按钮时，会发出消息WM_CLOSE，这里没对其处理，因此，由函数DefWindowsProc处理，这个函数会调用Destroy函数把窗口擦除，然后发出消息WM_DESTROY，窗口函数收到WM_DESTROY后会调用函数PostQuitMessage，这个函数会发出消息WM_QUIT让while循环结束消息处理，完成程序退出操作。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>小试基于vux开发跨平台app</title>
      <link href="/2020/09/10/%E5%B0%8F%E8%AF%95%E5%9F%BA%E4%BA%8Evux%E5%BC%80%E5%8F%91%E8%B7%A8%E5%B9%B3%E5%8F%B0app/"/>
      <url>/2020/09/10/%E5%B0%8F%E8%AF%95%E5%9F%BA%E4%BA%8Evux%E5%BC%80%E5%8F%91%E8%B7%A8%E5%B9%B3%E5%8F%B0app/</url>
      
        <content type="html"><![CDATA[<p>最近项目需要基于<a href="https://doc.vux.li/zh-CN/" target="_blank" rel="noopener">vux</a>开发跨平台的app，从零开始的小白，摸索了一天多，大概知道了流程，现在记录下：</p><p>1.新建项目，这里我不使用ESLint.<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200910220012.png" alt=""></p><p>初始化完成后如下：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200910220039.png" alt=""></p><p>2.安装依赖<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200910220058.png" alt=""></p><p>3.测试运行<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200910220118.png" alt=""></p><p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200910220129.png" alt=""></p><p>4.部署到真机<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200910220147.png" alt=""></p><p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200910220157.png" alt=""></p><p>打开HBuilder，新建移动APP项目:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200910220213.png" alt=""></p><p>把上面生成的index.html和static文件夹拷贝到这个项目，覆盖原有文件即可:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200910220233.png" alt=""></p><p>运行。可以选择模拟器或真机运行，这里我选择真机：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200910220247.png" alt=""></p><p>HBuilder同步完文件后如下：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200910220301.png" alt=""></p><p>在手机桌面点击”HBuilder”时弹出如下窗口：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200910220316.png" alt=""></p><p>我们需要手动信任该企业证书：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200910220328.png" alt=""></p><p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200910220341.png" alt=""></p><p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200910220359.png" alt=""></p><p>点击”Trust”即可：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200910220417.png" alt=""></p><p>打开后发现页面空白，什么都没，和上面的开发运行的页面不一样的……<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200910220431.png" alt=""></p><p>修改config/index.js文件，如下：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200910220443.png" alt=""></p><p>5.流程就是这样子，后面的组件还有页面开发啥的，就和前端开发差不多的了，这里就不多写了。</p>]]></content>
      
      
      <categories>
          
          <category> Frontend </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot项目application.yml文件数据库配置密码加密</title>
      <link href="/2020/09/10/Spring-Boot%E9%A1%B9%E7%9B%AEapplication-yml%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE%E5%BA%93%E9%85%8D%E7%BD%AE%E5%AF%86%E7%A0%81%E5%8A%A0%E5%AF%86/"/>
      <url>/2020/09/10/Spring-Boot%E9%A1%B9%E7%9B%AEapplication-yml%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE%E5%BA%93%E9%85%8D%E7%BD%AE%E5%AF%86%E7%A0%81%E5%8A%A0%E5%AF%86/</url>
      
        <content type="html"><![CDATA[<p>在Spring boot开发中，需要在application.yml文件里配置数据库的连接信息，或者在启动时传入数据库密码，如果不加密，传明文，数据库就直接暴露了，相当于”裸奔”了，因此需要进行加密处理才行。</p><p>如果使用@SpringBootApplication注解启动的项目，只需增加maven依赖，其他方式请参考<a href="https://github.com/ulisesbocchio/jasypt-spring-boot" target="_blank" rel="noopener">GitHub地址</a>的README信息:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200910215328.png" alt=""></p><p>我们对信息加解密是使用这个jar包的：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200910215344.png" alt=""></p><p>编写加解密测试类:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200910215445.png" alt=""></p><p>首先运行testEncrypt()，明文是<code>linjingke</code>，加密密钥是<code>ljk</code>，密钥可以自己定，运行输出如下为：</p><blockquote><p>aHsFtlQjatrOP2s8bfLGkUG55z53KLNi</p></blockquote><p>然后运行testDe()，加密后的串为aHsFtlQjatrOP2s8bfLGkUG55z53KLNi，输出的明文为linjingke。</p><p>加解密可以。</p><p>另外，也可以通过命令行方式处理：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200910215540.png" alt=""></p><p>可以发现，同样的明文和加密密钥，加密后的串却不一样。</p><p>加密串拿到了，现在来修改application.yml的配置：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200910215611.png" alt=""></p><p>我们把加密串放在ENC({加密串})即可。</p><p>还要加这个密钥的配置：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200910215634.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Springboot </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot应用启动流程初探</title>
      <link href="/2020/09/10/Spring-Boot%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%9D%E6%8E%A2/"/>
      <url>/2020/09/10/Spring-Boot%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<p>用了一段时间Spring Boot进行开发，它的确省了开发人员很多配置的时间，那么，它背后是怎么启动的，今天来探究一下……</p><blockquote><p>话说，这篇文章标题开始写于2018年9月某日，今天(2019年11月某日)才在草稿箱捡起来重新补完，囧大发…………</p></blockquote><p>以下示例采用SpringBoot2.0.5进行开发测试，其Spring FrameWork版本为5.0，要求JDK1.8。在使用maven下载镜像时，为了加快下载速度，这里使用阿里云的镜像地址：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200910214434.png" alt=""></p><p>首先，创建一个最简单的只有一个starter-web的模块依赖的spring boot项目，如下：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200910214453.png" alt=""></p><p>这里注意到，这里有一个父POM直接指向了spring boot的pom，如果需要依赖其他自定义的父POM就不行了，这里稍作修改如下：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200910214523.png" alt=""></p><p>执行mvn package打包后，目录结构如下：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200910214541.png" alt=""></p><p>这两个jar包，15MB左右的可以java -jar启动，它包含了很多以来库，如tomcat等，而.original后缀的文件仅包含该项目应用的本地资源，如编译后的classes目录下的资源文件，它并未引入第三方依赖资源，所以占用空间较小。我们解压第一个jar包看看：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200910214600.png" alt=""></p><p>BOOT-INF/classes目录存放的是应用编译后的class文件；</p><ul><li>BOOT-INF/lib存放的是应用依赖的JAR包；</li><li>META-INF目录存放的是应用相关的元信息，如MANIFEST.MF文件(根据JAR文件规定，该文件一定存放于META-INF目录下)；</li><li>org目录存放Spring BOOT相关的class文件。</li></ul><p>接下来，看看MANIFEST.MF文件，它描述了关于jar包的很多信息：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200910214643.png" alt=""></p><p>发现一个特点，有Main-Class和Start-Class，回忆一下刚学Java时，只有一个类文件，如Hello.class，我们是通过java Hello命令去执行的，既然现在知道Main-Class了，我们试下：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200910214710.png" alt=""></p><p>应用正常启动，说明我们自己的Start-Class是被这个启动类来进行加载并初始化的，而JarLauncher会在BOOT-INF/lib目录下找到需要类库依赖去启动，如下源码所示，这里就有一个main函数：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200910214735.png" alt=""></p><p>下面是我们代码中的启动类:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200910214750.png" alt=""></p><p>可以发现，Spring boot项目核心有两个组件：</p><ol><li>SpringApplication负责Spring应用程序的启动</li><li>@SpringBootApplication注解来简化应用的配置</li></ol><p>整个应用的启动类为<code>org.springframework.boot.loader.JarLauncher</code>，其继承关系如下：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200910214854.png" alt=""></p><p>为了方便看到Launcher源码，这里加一个其依赖：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200910214909.png" alt=""></p><p>然后打开下载JarLauncher的源码。</p><p>在其源码可以看到，指定了启动时去classes路径BOOT-INF/classes/下和库路径BOOT-INF/lib/下查询archive资源文件然后用默认或自定义的classloader进行加载。真正的启动代码在这里：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200910214937.png" alt=""></p><p>囧，跟了下代码，里面涉及不少java的东西我还不怎么了解，如Archive、URLStreamHandler等，有点晕，先此结笔，后面再补充完善了……</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Springboot </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>浏览器Vue-devtools工具安装</title>
      <link href="/2020/09/09/%E6%B5%8F%E8%A7%88%E5%99%A8Vue-devtools%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85/"/>
      <url>/2020/09/09/%E6%B5%8F%E8%A7%88%E5%99%A8Vue-devtools%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>在浏览器F12查看vue项目的控制台，看到如下信息：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200909222216.png" alt=""></p><p>默认安装需要打开goole网站，需要跳墙，这里下载它的代码来安装吧……</p><blockquote><p>git clone <a href="https://github.com/vuejs/vue-devtools.git" target="_blank" rel="noopener">https://github.com/vuejs/vue-devtools.git</a></p></blockquote><p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200909222243.png" alt=""></p><p>clone完成后，进入vue-devtools目录，首先执行命令<code>npm install</code>安装依赖：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200909222308.png" alt=""></p><p>报如下错误，在windows平台可以忽略…………：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200909222327.png" alt=""></p><p>然后编译<code>npm run build</code>生成插件:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200909222346.png" alt=""></p><p>打开Chrome浏览器的扩展程序：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200909222404.png" alt=""></p><p>勾选开发者模式，才会显示箭头指向的两个按钮:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200909222420.png" alt=""></p><p>点击“加载已解压的扩展程序”，选择刚刚编译生成的目录：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200909222438.png" alt=""></p><p>重启chrome浏览器，再次F12打开控制台，可以看到Vue项目，它有vue原本的标签，而不是只是生成的html标签：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200909222456.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Frontend </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>XAMPP启动提示43端口被占用问题解决</title>
      <link href="/2020/09/09/XAMPP%E5%90%AF%E5%8A%A8%E6%8F%90%E7%A4%BA43%E7%AB%AF%E5%8F%A3%E8%A2%AB%E5%8D%A0%E7%94%A8%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
      <url>/2020/09/09/XAMPP%E5%90%AF%E5%8A%A8%E6%8F%90%E7%A4%BA43%E7%AB%AF%E5%8F%A3%E8%A2%AB%E5%8D%A0%E7%94%A8%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<p>使用XAMPP部署服务启动Apache时提示443端口被占用，看看啥原因：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200909221950.png" alt=""></p><p>看看6656是哪个进程：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200909222008.png" alt=""></p><p>原来是装了VMWare，其实也可以修改httpd-ssl.conf配置文件使用其他SSL端口，但是不想这样改，这个进程VMWare Workstation Server（vmware-hostd.exe）主要与远程管理VMWare有关，一般很少用到，那就停用它吧，这里把启动方式改为手动吧：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200909222030.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux安装oh-my-zsh</title>
      <link href="/2020/09/09/Linux%E5%AE%89%E8%A3%85oh-my-zsh/"/>
      <url>/2020/09/09/Linux%E5%AE%89%E8%A3%85oh-my-zsh/</url>
      
        <content type="html"><![CDATA[<p>Linux下默认的shell是bash，之前在Mac系统习惯了oh-my-zsh，功能更加强大，现在在centos7服务器安装下：</p><ol><li><p>查看当前系统已安装的shell:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200909221547.png" alt=""></p></li><li><p>没有安装到zsh，现在来进行安装：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200909221607.png" alt=""></p></li><li><p>切换当前默认shell为zsh:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200909221631.png" alt=""><br>切换后需要重新登录。</p></li><li><p>重新登录会提示配置一下zsh，按提示做即可：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200909221655.png" alt=""></p></li><li><p>通过git安装oh-my-zsh</p><blockquote><p>wget <a href="https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh" target="_blank" rel="noopener">https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh</a> -O - | sh</p></blockquote></li></ol><p>如下所示：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200909221727.png" alt=""></p><p>6.安装成功：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200909221747.png" alt=""></p><p>后面进行自己的自定义配置即可。 </p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring Security基本原理(Spring Boot1.x版本适用，2.x部分配置参数会变)</title>
      <link href="/2020/09/09/Spring-Security%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86-Spring-Boot1-x%E7%89%88%E6%9C%AC%E9%80%82%E7%94%A8%EF%BC%8C2-x%E9%83%A8%E5%88%86%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0%E4%BC%9A%E5%8F%98/"/>
      <url>/2020/09/09/Spring-Security%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86-Spring-Boot1-x%E7%89%88%E6%9C%AC%E9%80%82%E7%94%A8%EF%BC%8C2-x%E9%83%A8%E5%88%86%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0%E4%BC%9A%E5%8F%98/</url>
      
        <content type="html"><![CDATA[<p>在SpringBoot开发时，通常都会对URI资源进行访问保护，就会引入如下starter模块：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200909211649.png" alt=""></p><p>这里暂时还没在yml文件配置auth服务的参数，因为这个oauth2的pom.xml文件里面也包含了spring security，所以可以直接使用：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200909211710.png" alt=""></p><p>如果不用Spring cloud，只用Spring boot，也可以直接引用，上面最终也是引用下面的依赖的：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200909211732.png" alt=""></p><p>spring boot的security-starter模块在引入后，没做任何配置的话，会对所有接口进行保护，因此，在访问的时候，会弹出登录框：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200909211759.png" alt=""></p><p>在spring启动时在日志中会输出一个默认的用户user的密码：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200909211822.png" alt=""></p><p>输入Username(默认: user)和Password即可正常登录访问。</p><p>我们可以在application.yml配置自己的用户名和密码:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200909211921.png" alt=""></p><p>默认的安全机制肯定不普遍适用，可以继承WebSecurityConfigurerAdapter来配置，然后重写configure方法来自定义验证处理逻辑：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200909212125.png" alt=""></p><p>前面的跳出登录窗口的处理其实默认的实现就是configure(HttpSecurity)，如下：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200909212200.png" alt=""></p><p>下面来自定义实现一下：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200909212519.png" alt=""></p><p>这样，在访问”/test”或”/login”接口就不需要验证直接访问，其他就需要登录了。我们还可以指定自己的登录页面，登录成功的处理器或登录失败的处理器等，如继承该类可以实现自己的登录成功处理逻辑<code>AbstractAuthenticationFilterConfigurer.java</code>：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200909212644.png" alt=""></p><p>如果需要配合自己业务系统的用户的用户进行验证，实现这个接口<code>org.springframework.security.core.userdetails.UserDetailsService</code>即可：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200909212734.png" alt=""></p><p>更多函数可以参考源码，进行测试调用即可。</p><p>大致使用了Spring Security后，不难理解，Spring Security其实就是很完善的过滤器链，在spring boot启动时初始化所有过滤器，然后用户的请求的服务的响应都会经过过滤器，类似我们在路由里面实现的ZuulFilter:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200909212812.png" alt=""></p><p>每个过滤器按照优先级进行逐级过滤，spring security的过滤器有用户名和密码验证<code>org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter.java</code>、第三方登录验证等过滤器，默认是基于用户名和密码的，在过滤器里，当收到用户请求后，就会判断请求是否有过滤器需要的验证信息，有就用对应的过滤器进行验证。所有的过滤器都是继承于抽象基类GenericFilterBean的，可以看到目前有如下几种过滤器的实现：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200909213042.png" alt=""></p><p>经过层层过滤器的验证后，最后会来到<code>org.springframework.security.web.access.intercept.FilterSecurityInterceptor.java</code>这个过滤器，这个类会检查经过前面验证过滤器的请求是否能访问后面的接口，可以则放行，否则，抛出无权限异常，会被<code>org.springframework.security.web.access.ExceptionTranslationFilter</code>类捕获：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200909213138.png" alt=""></p><p>整个过滤器链流程如下所示：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200909213206.png" alt=""></p><p>这个过程可以自己在相应类下断点调试看看流程是否真的这样执行。有了前面的几个过滤器，那么，整个认证过程流程，大致涉及如下几个核心类串起来的：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200909213239.png" alt=""></p><p>应用启动后，不是所有过滤器都会生效的，spring boot会根据我们的配置，如我们前面配置了formLogin()这个过滤器，那么这个过滤器就生效而其他过滤器不生效，但是，在上面过滤器链中，绿色的才是可配置是否生效的，其他颜色的，一定会在过滤器链中。</p><p>前面我们配置了用户名密码登录，在登录界面点击了”登录”按钮后，我们首先会进入这个<code>org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter.java</code>过滤器：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200909213313.png" alt=""></p><p>获取了用户信息后，开始进行校验处理<code>org.springframework.security.authentication.ProviderManager.java</code>：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200909213353.png" alt=""></p><p>这里用for循环去执行验证器，这里用户名和密码的验证器为如下：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200909213412.png" alt=""></p><p>认证成功后，会在<code>org.springframework.security.web.authentication.AbstractAuthenticationProcessingFilter</code>类的successfulAuthentication方法把当前登录用户信息写到session里：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200909213444.png" alt=""></p><p>因为一次请求和响应在一个线程中处理，所以，把当前请求的认证信息放到SecurityContextHolder里，它是ThreadLocal的，因此，所以可以在任何地方获取到当前登录用户的信息。<br>请求进来，会先进入到这个过滤器：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200909213506.png" alt=""><br>它会进行请求和响应信息的session处理，这样，用户登录后，在进行其他请求时，都能获得登录用户的信息。<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200909213529.png" alt=""></p><p>今天踩坑了，不得不好好了解下Spring Security，大致流程就这样，后面有时间再补充缺少的理解吧。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IDEA启动Spring Boot项目报错Command line is too long解决</title>
      <link href="/2020/09/08/IDEA%E5%90%AF%E5%8A%A8Spring-Boot%E9%A1%B9%E7%9B%AE%E6%8A%A5%E9%94%99Command-line-is-too-long%E8%A7%A3%E5%86%B3/"/>
      <url>/2020/09/08/IDEA%E5%90%AF%E5%8A%A8Spring-Boot%E9%A1%B9%E7%9B%AE%E6%8A%A5%E9%94%99Command-line-is-too-long%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<p>修改项目根目录下文件夹”.idea”的工作空间配置文件：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200908233437.png" alt=""></p><p>在如下节点增加配置即可：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200908233451.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WindowsServer2008打开IIS页面报错“错误号：3706 错误描述：未找到提供程序。该程序可能未正确安装”解决</title>
      <link href="/2020/09/08/WindowsServer2008%E6%89%93%E5%BC%80IIS%E9%A1%B5%E9%9D%A2%E6%8A%A5%E9%94%99%E2%80%9C%E9%94%99%E8%AF%AF%E5%8F%B7%EF%BC%9A3706-%E9%94%99%E8%AF%AF%E6%8F%8F%E8%BF%B0%EF%BC%9A%E6%9C%AA%E6%89%BE%E5%88%B0%E6%8F%90%E4%BE%9B%E7%A8%8B%E5%BA%8F%E3%80%82%E8%AF%A5%E7%A8%8B%E5%BA%8F%E5%8F%AF%E8%83%BD%E6%9C%AA%E6%AD%A3%E7%A1%AE%E5%AE%89%E8%A3%85%E2%80%9D%E8%A7%A3%E5%86%B3/"/>
      <url>/2020/09/08/WindowsServer2008%E6%89%93%E5%BC%80IIS%E9%A1%B5%E9%9D%A2%E6%8A%A5%E9%94%99%E2%80%9C%E9%94%99%E8%AF%AF%E5%8F%B7%EF%BC%9A3706-%E9%94%99%E8%AF%AF%E6%8F%8F%E8%BF%B0%EF%BC%9A%E6%9C%AA%E6%89%BE%E5%88%B0%E6%8F%90%E4%BE%9B%E7%A8%8B%E5%BA%8F%E3%80%82%E8%AF%A5%E7%A8%8B%E5%BA%8F%E5%8F%AF%E8%83%BD%E6%9C%AA%E6%AD%A3%E7%A1%AE%E5%AE%89%E8%A3%85%E2%80%9D%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<p>在windows server 2008部署asp网站后打开页面时报如下错误：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200908232937.png" alt=""></p><p>这是因为在64位系统中，iis7的应用程序池默认没有启用32位程序。因此，修改默认应用程序池的配置，启用32位应用程序重启网站即可：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200908232956.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WindowsServer2008打开IIS子页面提示不能使用&#39;..&#39;作为父目录问题解决</title>
      <link href="/2020/09/08/WindowsServer2008%E6%89%93%E5%BC%80IIS%E5%AD%90%E9%A1%B5%E9%9D%A2%E6%8F%90%E7%A4%BA%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8-%E4%BD%9C%E4%B8%BA%E7%88%B6%E7%9B%AE%E5%BD%95%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
      <url>/2020/09/08/WindowsServer2008%E6%89%93%E5%BC%80IIS%E5%AD%90%E9%A1%B5%E9%9D%A2%E6%8F%90%E7%A4%BA%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8-%E4%BD%9C%E4%B8%BA%E7%88%B6%E7%9B%AE%E5%BD%95%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<p>在iis7上打开子目录的主页时提示如下错误：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200908232815.png" alt=""></p><p>需要在网站启用父目录：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200908232830.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Kettle导数据到MySQL时空字符串转null值处理</title>
      <link href="/2020/09/08/Kettle%E5%AF%BC%E6%95%B0%E6%8D%AE%E5%88%B0MySQL%E6%97%B6%E7%A9%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%ACnull%E5%80%BC%E5%A4%84%E7%90%86/"/>
      <url>/2020/09/08/Kettle%E5%AF%BC%E6%95%B0%E6%8D%AE%E5%88%B0MySQL%E6%97%B6%E7%A9%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%ACnull%E5%80%BC%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>在用Kettle对mysql导入数据插入空值(‘’)时，发现对空值的处理会自动转转换为null值，此时需要在kettle.properties文件中添加如下参数即可。</p><p>kettle.properties文件的位置:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200908232611.png" alt=""></p><p>添加的参数如下：<br><code>KETTLE_EMPTY_STRING_DIFFERS_FROM_NULL=Y</code></p>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Lists的坑点记录</title>
      <link href="/2020/09/08/Lists%E7%9A%84%E5%9D%91%E7%82%B9%E8%AE%B0%E5%BD%95/"/>
      <url>/2020/09/08/Lists%E7%9A%84%E5%9D%91%E7%82%B9%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Arrays-asList，把数据转为List"><a href="#Arrays-asList，把数据转为List" class="headerlink" title="Arrays.asList，把数据转为List"></a>Arrays.asList，把数据转为List</h1><p>看如下代码结果：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200908210648.png" alt=""></p><p>运行：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200908210706.png" alt=""></p><p>原因分析：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200908210745.png" alt=""></p><p>查看源码可知，该函数的参数是一个泛型T可变参数，上面的int[]数组整体作为了参数。如果要实现想要的效果，需要如下处理，即把int数组转为Integer数组：<br><code>Arrays.stream(a).boxed().collect(Collectors.toList()).size()</code></p><h1 id="操作Arrays-asList返回的List"><a href="#操作Arrays-asList返回的List" class="headerlink" title="操作Arrays.asList返回的List"></a>操作Arrays.asList返回的List</h1><p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200908211612.png" alt=""></p><p>查看源码可以知道，Arrays.asList返回的List不是java.util.List，而是其内部类ArrayList，其对增删接口未实现，因此对返回的List添加元素会报异常。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows系统安装fdfs-client错误解决</title>
      <link href="/2020/09/05/Windows%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85fdfs-client%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3/"/>
      <url>/2020/09/05/Windows%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85fdfs-client%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<p>在Windows安装Python连接FastDFS的客户端与Linux稍微不太一样，这里记录一下：</p><p>首先下载fdfs_client-py-1.2.6，按照python的软件通用安装方法，如下:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200905114345.png" alt=""></p><p>提示需要安装Microsoft Visual C++ 9.0, 安装提示去下载<a href="http://aka.ms/vcpython27" target="_blank" rel="noopener">vcforpython27.msi</a>，安装后，继续执行<code>python setup.py install</code>，报如下错误:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200905114519.png" alt=""></p><p>这里需要修改两个地方：</p><ol><li><p>setup.py文件，注释圈住的两行:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200905114541.png" alt=""></p></li><li><p>修改fdfs_client/storage_client.py文件，注释圈住的一行:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200905114605.png" alt=""></p></li></ol><p>再次安装即可以安装成功了。</p><p>虽然这样可以安装成功，但是实际使用有部分功能可能会执行失败或报错，因此，建议还是在类linux系统上进行实际业务操作。</p>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python二维码生成</title>
      <link href="/2020/09/05/Python%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%94%9F%E6%88%90/"/>
      <url>/2020/09/05/Python%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%94%9F%E6%88%90/</url>
      
        <content type="html"><![CDATA[<p>依赖包生成：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200905114027.png" alt=""></p><p>PyMySQL安装(Python3.x不支持MySQLdb了)<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200905114049.png" alt=""></p><p>代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="keyword">import</span> qrcode</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">'qrcode'</span>):</span><br><span class="line">    os.mkdir(<span class="string">'qrcode'</span>)</span><br><span class="line">    </span><br><span class="line">os.chdir(os.getcwd() + <span class="string">'/qrcode'</span>)</span><br><span class="line"> </span><br><span class="line">db = pymysql.connect(host=<span class="string">"xxxx"</span>, port=xxxx,</span><br><span class="line">                     user=<span class="string">"xxxx"</span>, passwd=<span class="string">"xxxx"</span>, </span><br><span class="line">                     db=<span class="string">"xxxx"</span>)</span><br><span class="line"> </span><br><span class="line">cursor = db.cursor()</span><br><span class="line"> </span><br><span class="line">sql = <span class="string">"SELECT * FROM xxx"</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    cursor.execute(sql)</span><br><span class="line">    results = cursor.fetchall()</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> results:</span><br><span class="line">        result = row[<span class="number">3</span>]</span><br><span class="line">        img = qrcode.make(result)</span><br><span class="line">        img.save(<span class="string">'%s.png'</span> % (result))</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">"Error: unable to fetch data"</span>)</span><br><span class="line"> </span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200905114131.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux下的网络监视工具-bmon</title>
      <link href="/2020/09/05/Linux%E4%B8%8B%E7%9A%84%E7%BD%91%E7%BB%9C%E7%9B%91%E8%A7%86%E5%B7%A5%E5%85%B7-bmon/"/>
      <url>/2020/09/05/Linux%E4%B8%8B%E7%9A%84%E7%BD%91%E7%BB%9C%E7%9B%91%E8%A7%86%E5%B7%A5%E5%85%B7-bmon/</url>
      
        <content type="html"><![CDATA[<p>bmon是一个Linux平台下不错的网络带宽监视工具，现在在Ubuntu上安装使用它，这里使用源码编译安装的方式。</p><p>首先安装依赖库：</p><blockquote><p>sudo apt-get install -y build-essential make libconfuse-dev libnl-3-dev libnl-route-3-dev libncurses-dev pkg-config dh-autoreconf</p></blockquote><p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200905112648.png" alt=""></p><p>接着，获取bmon的源码：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200905112705.png" alt=""></p><p>下载完成后，进入bmon根目录，按如下操作:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200905112725.png" alt=""></p><p>安装完成后，执行命令”bmon”即可进入bmon界面：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200905112739.png" alt=""></p><p>上面列处理两个网卡的网络信息”lo”与”eth0”，可以上下箭头查看信息，输入问号”?”可以显示相关按键帮助信息。bmon的相关帮助加入”–help”参数即可查看”bmon –help”。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu下QT编译错误-Cann-t-find-lGl的解决</title>
      <link href="/2020/09/05/Ubuntu%E4%B8%8BQT%E7%BC%96%E8%AF%91%E9%94%99%E8%AF%AF-Cann-t-find-lGl%E7%9A%84%E8%A7%A3%E5%86%B3/"/>
      <url>/2020/09/05/Ubuntu%E4%B8%8BQT%E7%BC%96%E8%AF%91%E9%94%99%E8%AF%AF-Cann-t-find-lGl%E7%9A%84%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<p>安装QT后，编译出现如下错误：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200905112437.png" alt=""></p><p>安装依赖包libglu1-mesa-dev即可：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200905112456.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Matlab图像界面编程</title>
      <link href="/2020/08/31/Matlab%E5%9B%BE%E5%83%8F%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/"/>
      <url>/2020/08/31/Matlab%E5%9B%BE%E5%83%8F%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>1.在Command Window输入”guide”, 弹出如下窗口：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200831231631.png" alt=""></p><p>选择默认的”Blank GUI(Default)”，显示界面编辑窗口:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200831231737.png" alt=""></p><p>2.在界面放置一个Axes和Push Button控件，如下:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200831232212.png" alt=""></p><p>双击按钮，可以打开按钮样式设置弹窗：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200831232334.png" alt=""></p><p>3.点击保存后，会生成对于的m文件，可以看到，按钮”打开图片”的回调函数也有了:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200831232550.png" alt=""></p><p>4.运行后，发现坐标轴显示，可以打开”Property Insptector”，把XTick和YTick里的数值全部delete就可以了，如下:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200831232657.png" alt=""></p><p>修改后：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200831233015.png" alt=""></p><p>5.编写打开图片和显示图片的代码:(axes控件可以显示多张图片的，这里先做显示一张的处理):<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200831234442.png" alt=""></p><p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200831234026.png" alt=""></p><p>运行结果：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200831234046.png" alt=""></p><p>6.生成独立执行的EXE可执行文件【Mac版】<br>Matlab命令行窗口输入<code>deploytool</code>，弹出窗口:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200831234634.png" alt=""></p><p>输入、选择基本信息，打包：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200831234937.png" alt=""><br>正在构建：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200831235016.png" alt=""></p><p>完成，在Matlab主文件夹输出打包工程文件：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200831235518.png" alt=""></p><p>打开发布包，居然600多兆：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200831235715.png" alt=""></p><p>安装时，需要安装运行时：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200831235815.png" alt=""></p><p>安装完成：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200831235942.png" alt=""></p><p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200901000022.png" alt=""></p><p>正常启动:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200901000428.png" alt=""></p><p>7.生成独立执行的EXE可执行文件【Windows版】<br>Matlab命令行窗口输入: deploytool，弹出窗口:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200831235202.png" alt=""></p><p>输入工程名字后，在界面右边出现新的一栏，选择Console Application:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200831235220.png" alt=""></p><p>添加m文件:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200831235234.png" alt=""></p><p>要生成没有安装Matlab的电脑都可以运行的EXE文件，需要添加MCR运行时环境，在”Package”里点击”Add MCR”，选择”Embeed the MCR in the Package”，然后点击”打包按钮”:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200831235253.png" alt=""></p><p>弹出如下窗口,点击确定即可开始:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200831235308.png" alt=""></p><p>然后开始build，可以发现，原来它是基于ant来构建的：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200831235327.png" alt=""></p><p>稍等片刻完成后，目录结构增加了若干文件夹，圈出来的就是打包后的文件，发给别人发这个就可以了:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200831235345.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Misc </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Neural Networks - 感知器</title>
      <link href="/2020/08/26/Neural-Networks-%E6%84%9F%E7%9F%A5%E5%99%A8/"/>
      <url>/2020/08/26/Neural-Networks-%E6%84%9F%E7%9F%A5%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>感知器(perception)是生物神经细胞的简单抽象，在百度上查一下“神经细胞”，得到如下图:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200826002837.png" alt=""></p><p>其中，树突用于获取外界信息刺激，细胞核用于对信息进行处理，轴突连接其他神经元，进行信息输出的传递(传递方向为<em>单向传递</em>)，基于这个概念，抽象出感知器来模拟神经细胞的这个活动。</p><p>单层感知器是一种最简单的单层前向人工神经网络，所谓单层，即除输入层和输出层之外，仅包含一层权值可变的神经元节点，主要用于处理<em>线性可分的二分类问题</em>（两类模式线性可分，算法一定收敛），其基本结构如下:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200826002935.png" alt=""></p><p>x1, x2, x3代表输入层(也叫感知层)，为3个神经元节点，负责引入外部信息，然后中间圆圈代表处理层，其具有信息处理能力，类似细胞核，工作过程就是一个感知器接收x1、x2、x3这三个二进制输入，并产生一个二进制输出。</p><p>考虑如下观点，五一快到了，你想去上海旅游，有3个考虑因素：</p><ol><li>上海天气怎么样？</li><li>住宿地方是否出行便捷？</li><li>约好的朋友是否有空陪同去？</li></ol><p>这三个因素对应x1, x2, x3，去上海对应output，是否要去取一个阈值5吧，然后把3个因素分别分配一个权重(权重表示相应输入对于输出重要性的实数)：3, 4, 3，也就是说，住宿的地方是否出行便捷对于最终是否去上海影响更大，然后每个因素乘以对应权重(假设天气不好：0，出行便捷:1，不陪同0)，得到结果为: <code>0*3 + 1*4 * 0*3 = 4 &lt; 5</code>，结果就是不去，类似可调整数值，而阈值代表了你想要去上海旅游的欲望，_值越小代表越愿意去_，因此，单层感知器可如下描述：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200826003122.png" alt=""></p><p>看到这个表达式，是不是感觉类似符号函数？其实，可以将感知器看作依据权重来做出决定的设备。</p><p>令输出为y, 阈值为b(-threshold)，输入对应x，权重对应w，则：<br><code>y = w1*x1 + w2*x2 + w3*x3 + b</code></p><p>这就是一条直线了，对于二维平面，感知器就对应一条直线，这样在平面上的数据就被这条直线分类了，大部分情况，是收敛的，特殊情况下，数据集会存在不收敛，这样就要调整数据集了。</p><p>下面用MatLab新建一个感知器来测试一下：</p><h3 id="A-样本数据准备："><a href="#A-样本数据准备：" class="headerlink" title="A. 样本数据准备："></a>A. 样本数据准备：</h3><p>（天气好1，不好0；  出行便捷1，不便捷0；   陪同1，不陪同0;  出行1，不出行0； 天气权重3， 便捷权重4， 陪同3，阈值5）<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200826003701.png" alt="">                 </p><p>这些输入表示为一个有3个元素的输入向量，输入元素的取值范围为[0 1]:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200826003730.png" alt=""></p><h3 id="B-创建感知器-设计为单层，单神经元的神经网络-："><a href="#B-创建感知器-设计为单层，单神经元的神经网络-：" class="headerlink" title="B. 创建感知器(设计为单层，单神经元的神经网络)："></a>B. 创建感知器(设计为单层，单神经元的神经网络)：</h3><p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200826003812.png" alt=""></p><p>newp函数用于生成一个感知器神经网络</p><h3 id="C-定义输入9-3样本向量"><a href="#C-定义输入9-3样本向量" class="headerlink" title="C. 定义输入9*3样本向量:"></a>C. 定义输入9*3样本向量:</h3><p>把上面样本数据定义为一个向量：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200826003843.png" alt=""></p><h3 id="D-定义目标向量："><a href="#D-定义目标向量：" class="headerlink" title="D. 定义目标向量："></a>D. 定义目标向量：</h3><p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200826003927.png" alt=""></p><h3 id="E-训练单层感知器神经网络"><a href="#E-训练单层感知器神经网络" class="headerlink" title="E. 训练单层感知器神经网络"></a>E. 训练单层感知器神经网络</h3><p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200826003943.png" alt=""></p><p>train函数用于训练创建好的感知器网络</p><p>输入训练后，弹出结果如右边窗口所示，看到感知器经过4次训练，使输出达到目标值，点击”Performance”，可以查看训练误差曲线：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200826004011.png" alt=""></p><h3 id="F-测试我们的感知器："><a href="#F-测试我们的感知器：" class="headerlink" title="F.测试我们的感知器："></a>F.测试我们的感知器：</h3><p>准备数据，分别对应上面样本数据的去与不去, 然后开始测试仿真：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200826004040.png" alt=""></p><p>可以得到结果就是1-&gt;去， 0-&gt;不去，可见设计的感知器达到目标需求。</p><p>小结一下，单层感知器的几个缺陷：</p><ol><li>感知器的激活函数使用阈值函数，使得输出只能取两个值(1/-1或0/1)，这限制了在分类种类上的扩展</li><li>感知器网络只对线性可分的问题收敛，如果问题不可分，感知器无法解决</li><li>感知器的学习算法只对单层有效，多层时无法直接套用规则</li><li>当输入样本存在奇异样本(样本数据部分值突然增大)，感知器网络运算需要花费很长时间</li></ol>]]></content>
      
      
      <categories>
          
          <category> ML </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>R语言环境安装与基本使用(一)</title>
      <link href="/2020/08/26/R%E8%AF%AD%E8%A8%80%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-%E4%B8%80/"/>
      <url>/2020/08/26/R%E8%AF%AD%E8%A8%80%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E4%B8%8E%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<p>R语言安装包可以从这个<a href="https://cran.r-project.org/mirrors.html" target="_blank" rel="noopener">地址</a>选择合适的URL去下载，这里使用<a href="https://mirrors.tuna.tsinghua.edu.cn/CRAN/" target="_blank" rel="noopener">这个</a>，如下：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200826001731.png" alt=""></p><p>下载对应平台的安装包即可，这里我下载Mac OS X的，目前版本是3.3.2。</p><blockquote><p>注意：<br>　　在下载文件描述可以看到，需要X11环境的支持，不过安装包已经包含这些&gt;必须的包在里面了！<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200826001817.png" alt=""></p></blockquote><p>安装完后，可以在应用程序看到图标“R”：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200826001852.png" alt=""></p><p>点击打开后界面如下：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200826001911.png" alt=""></p><p>当然，也有图形界面编辑器：<a href="https://www.rstudio.com/products/rstudio/" target="_blank" rel="noopener">RStudio</a>, RStudio还有一种更方便的安装，使用Anaconda，在软件界面有R图标，提示”Install”，点击安装等待安装即可:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200826002014.png" alt=""></p><p>输入“library()”可以查看已经安装的包：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200826002205.png" alt=""></p><p>要查看帮助函数，输入”help(xxx)”或”? xxx”即可，或”help.start()”打开帮助文档首页：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200826002233.png" alt=""></p><p>要知道sin函数怎么用，输入”example(“sin”)”即可；</p><p>需要获取或改变工作目录，输入”getwd()”或”setwd(“&lt;目录路径&gt;”)”</p><p>要安装扩展包，输入“install.packages(“&lt;包名&gt;”)”，按提示选择安装源和需要安装的包即可，在RStudio安装更简单，点击右下角”Install”标记，弹出下载包对话框，输入包名，等待安装完即可：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200826002336.png" alt=""></p><p>在交互终端输入”q()”可退出R。</p>]]></content>
      
      
      <categories>
          
          <category> R </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java序列化使用jackson时首字母变成小写问题解决</title>
      <link href="/2020/08/23/Java%E5%BA%8F%E5%88%97%E5%8C%96%E4%BD%BF%E7%94%A8jackson%E6%97%B6%E9%A6%96%E5%AD%97%E6%AF%8D%E5%8F%98%E6%88%90%E5%B0%8F%E5%86%99%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
      <url>/2020/08/23/Java%E5%BA%8F%E5%88%97%E5%8C%96%E4%BD%BF%E7%94%A8jackson%E6%97%B6%E9%A6%96%E5%AD%97%E6%AF%8D%E5%8F%98%E6%88%90%E5%B0%8F%E5%86%99%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<p>在使用jackson反序列化json字符串到对象时，发现，属性的首字母会变成小写，从而造成找不到属性的异常：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200823001737.png" alt=""></p><p>可以在属性加如下注解解决：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200823001756.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue+ElementUI重置表单数据至初始值</title>
      <link href="/2020/08/20/Vue-ElementUI%E9%87%8D%E7%BD%AE%E8%A1%A8%E5%8D%95%E6%95%B0%E6%8D%AE%E8%87%B3%E5%88%9D%E5%A7%8B%E5%80%BC/"/>
      <url>/2020/08/20/Vue-ElementUI%E9%87%8D%E7%BD%AE%E8%A1%A8%E5%8D%95%E6%95%B0%E6%8D%AE%E8%87%B3%E5%88%9D%E5%A7%8B%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<p>在基于Vue+ElementUI开发页面时，表单数据重置时，之前是写一个函数去一个个参数恢复初始值，后来发现有个更快速的方式，如下所示：</p><ol><li><p>el-form标签加一个ref参数<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200820215634.png" alt=""><br>model的params参数值如下：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200820215705.png" alt=""></p></li><li><p>(这里只有一个参数，多个参数类似)表单的多个数据el-form-item加一个prop参数<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200820215716.png" alt=""></p></li><li><p>重置函数传入el-form的ref参数值<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200820215743.png" alt=""></p></li><li><p>实现reset(..)函数即可<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200820215755.png" alt=""></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Frontend </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下截屏软件SnapShot</title>
      <link href="/2020/08/20/Linux%E4%B8%8B%E6%88%AA%E5%B1%8F%E8%BD%AF%E4%BB%B6SnapShot/"/>
      <url>/2020/08/20/Linux%E4%B8%8B%E6%88%AA%E5%B1%8F%E8%BD%AF%E4%BB%B6SnapShot/</url>
      
        <content type="html"><![CDATA[<p>Linux下一款不错的截屏软件： Snap Shot</p><p>执行<code>sudo yum install snapshot</code>进行安装，下载完成后可以在应用程序里打开。 </p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人脸特征检测--基于DLIB库</title>
      <link href="/2020/08/20/%E4%BA%BA%E8%84%B8%E7%89%B9%E5%BE%81%E6%A3%80%E6%B5%8B-%E5%9F%BA%E4%BA%8EDLIB%E5%BA%93/"/>
      <url>/2020/08/20/%E4%BA%BA%E8%84%B8%E7%89%B9%E5%BE%81%E6%A3%80%E6%B5%8B-%E5%9F%BA%E4%BA%8EDLIB%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>Dlib是一个C++编写的工具包，它包含了机器学习算法以及一些用来解决现实复杂问题的工具，可以广泛应用于机器人、嵌入式设备、手机，甚至高性能计算中，可以在其<a href="http://dlib.net" target="_blank" rel="noopener">官网</a>了解更多。这里下载它来试用一下，下载后解压，目录结构如下:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200820214502.png" alt=""></p><p>在examples目录下是C++的一些例子，我们可以参考来学习下怎么使用：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200820214527.png" alt=""></p><p>下面基于这个库来检测一下人脸的特征数据，使用Eclipse For CPP IDE新建一个空的C++的Makefile工程，然后新建main.cpp与makefile文件，并复制官方的人脸识别文件到工程目录下，完成后项目结构如下：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200820214603.png" alt=""></p><ul><li>“shape_predictor_xxxx”就是已经弄好的人脸识别数据文件，可以百度下载即可。</li><li>“2.png”是一张人脸，就取我的证件照吧，哈哈～</li></ul><p>为了能够跳转查看头文件，配置一下dlib库的include路径:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200820214649.png" alt=""></p><p>编辑main.cpp文件如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlib/opencv.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlib/image_processing/frontal_face_detector.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlib/image_processing/render_face_detections.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlib/image_processing.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlib/gui_widgets.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> dlib;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> </span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[], <span class="keyword">char</span> **env) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"OpenCV Version: "</span> &lt;&lt; CV_VERSION &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">Mat source = imread(<span class="string">"2.png"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Detecting, wait a minute..."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">double</span> start = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(getTickCount());</span><br><span class="line"> </span><br><span class="line">frontal_face_detector detector = get_frontal_face_detector();</span><br><span class="line">shape_predictor pose_model;</span><br><span class="line">deserialize(<span class="string">"shape_predictor_68_face_landmarks.dat"</span>) &gt;&gt; pose_model;</span><br><span class="line"> </span><br><span class="line"><span class="function">cv_image&lt;bgr_pixel&gt; <span class="title">cimg</span><span class="params">(source)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;dlib::rectangle&gt; faces = detector(cimg);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;full_object_detection&gt; shapes;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">long</span> i = <span class="number">0</span>; i &lt; faces.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    shapes.push_back(pose_model(cimg, faces[i]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!shapes.empty()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">68</span>; i++) &#123;</span><br><span class="line"><span class="built_in">circle</span>(source, cvPoint(shapes[<span class="number">0</span>].part(i).x(), shapes[<span class="number">0</span>].part(i).y()),</span><br><span class="line"><span class="number">3</span>, cv::Scalar(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>), <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">double</span> <span class="built_in">end</span> = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(getTickCount());</span><br><span class="line"><span class="keyword">double</span> seconds = (<span class="built_in">end</span>-start) / getTickFrequency();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Detect finish, time: "</span> &lt;&lt; seconds &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        imshow(<span class="string">"Face Feature"</span>, source);</span><br><span class="line"> </span><br><span class="line">waitKey();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (exception &amp;e) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"[Error]: "</span> &lt;&lt; e.what() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编辑Makefile文件如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">TARGET = main</span><br><span class="line">SRC_FILES = main.cpp \</span><br><span class="line">/home/linjk/usr/dlib-19.4/dlib/all/source.cpp</span><br><span class="line">COMPILER = g++</span><br><span class="line">CXXFLAGS = -Wall -std=c++11 -lX11 -lpthread</span><br><span class="line">INCLUDE_DLIB = /home/linjk/usr/dlib-19.4/</span><br><span class="line">LIB_PATH = /usr/local/lib/</span><br><span class="line">LINK_LIBS_OPENCV = -lopencv_videoio \</span><br><span class="line">-lopencv_core \</span><br><span class="line">-lopencv_highgui \</span><br><span class="line">-lopencv_imgproc \</span><br><span class="line">-lopencv_imgcodecs</span><br><span class="line"></span><br><span class="line"><span class="variable">$(TARGET)</span>:<span class="variable">$(SRC_FILES)</span></span><br><span class="line"><span class="variable">$(COMPILER)</span> -o <span class="variable">$(TARGET)</span> <span class="variable">$(SRC_FILES)</span> <span class="variable">$(CXXFLAGS)</span>\</span><br><span class="line">-I<span class="variable">$(INCLUDE_DLIB)</span> -L<span class="variable">$(LIB_PATH)</span> <span class="variable">$(LINK_LIBS_OPENCV)</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">rm -rf <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure><p>这里定义的目标可执行文件main的编译规则，在其他平台修改这个文件的-I或-L参数，指向正确的路径即可。<br>编译执行结果如下：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200820214832.png" alt=""></p><p>左边是特征点检测结果，右边是从0到67总共68个点的特征数据本地保持，结果输出，检测完用了5.02秒，这里人脸部分图片越小，时间越短，经过Mac与Ubuntu的执行时间对比，Ubuntu比Mac居然快了1秒，而Ubuntu是运行在虚拟机上面的<del>~</del></p><p>后续再用这个数据来进行分析了。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> dlib </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dlib </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CUDA入门(一)环境安装</title>
      <link href="/2020/08/20/CUDA%E5%85%A5%E9%97%A8-%E4%B8%80-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"/>
      <url>/2020/08/20/CUDA%E5%85%A5%E9%97%A8-%E4%B8%80-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>最近进行一些项目，发现单纯用CPU来处理，感觉好慢……后来听说了CUDA这玩意挺好，就摆弄下，之前小小用过一下MPI，但是因为忙，没怎么系统去使用，所以思维还没完全转变过来，对比了一下，CUDA对于更好使用与理解并行编程很不错，就先从CUDA好好入门吧。</p><p>台式机原来是核显，网上看了看，最终入手了<strong>GT730K</strong>这款显卡，买来后，安装到主板上即可，注意，视频线要接新的显卡输出信号口，第一次开机，系统还没检测到显卡，开机使用了一会，系统就自己安装好驱动了，我还没使用提供的驱动盘安装，驱动安装好后，显示如下：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200820213438.png" alt=""></p><p>查看显卡支持的CUDA版本，首先打开NVIDIA的控制面板，然后点击“帮助”–“系统信息”，在弹出窗口选择“组件”，可以看到，当前显卡支持CUDA Tool kit的版本:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200820213522.png" alt=""></p><p>然后去<a href="https://developer.nvidia.com/cuda-toolkit-archive" target="_blank" rel="noopener">NVIDIA</a>下载对应版本的开发工具包，下载后如下：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200820213601.png" alt=""><br>双击运行，提示解压保存路径，选一个路径即可：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200820213649.png" alt=""></p><p>解压后出现如下界面：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200820213716.png" alt=""></p><p>在这一步会检测你的显卡是否支持CUDA，如果不支持，就不能下一步了，按照提示一步步操作，即可，中间提示是否安装Visual Studio插件，为了方便开发，都安装了，但是，目前NVIDIA开发包最高只支持到2015，最新的Visual Studio 2017暂时还不支持。安装完成：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200820213753.png" alt=""></p><p>安装后，有一些官方提供的例子：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200820213822.png" alt=""></p><p>打开Samples_vs2015.sln来看看，好多例程：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200820213848.png" alt=""></p><p>运行SimpleTexture3D看看如何：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200820213917.png" alt=""></p><p>运行如下，图是动的，这里只截取静态的:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200820213940.png" alt=""></p><p>另外，再看看deviceQuery运行结果。它输出了这个显卡的信息：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200820214012.png" alt=""></p><p>算一下计算能力：384 x 0.96=364.8GFLOPS(FLOPS是Floating-point Operations Per Second每秒所执行的浮点运算次数的缩写，它是一个衡量计算能力的量，GFLOPS就是Giga Floating-point Operations Per Second，即每秒10亿次的浮点运算数)，再看看我电脑原来CPU的计算能力:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200820214106.png" alt=""></p><p>2.7 x 4=10.8, GPU的运算能力差不多是CPU的(364.8/10.8=33.7777777…..)34倍了！！！</p><p>再看看新建项目时，可以看到，有NVIDIA的模板了:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200820214140.png" alt=""></p><p>上面都运行可以，说明环境已经配置成功，后面就可以进入实际开发使用阶段。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> CUDA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CUDA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7正确配置了samba服务，Windows能登陆当提示没权限问题解决</title>
      <link href="/2020/08/06/CentOS7%E6%AD%A3%E7%A1%AE%E9%85%8D%E7%BD%AE%E4%BA%86samba%E6%9C%8D%E5%8A%A1%EF%BC%8CWindows%E8%83%BD%E7%99%BB%E9%99%86%E5%BD%93%E6%8F%90%E7%A4%BA%E6%B2%A1%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
      <url>/2020/08/06/CentOS7%E6%AD%A3%E7%A1%AE%E9%85%8D%E7%BD%AE%E4%BA%86samba%E6%9C%8D%E5%8A%A1%EF%BC%8CWindows%E8%83%BD%E7%99%BB%E9%99%86%E5%BD%93%E6%8F%90%E7%A4%BA%E6%B2%A1%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<p>关闭SELinux即可。</p><h3 id="临时关闭"><a href="#临时关闭" class="headerlink" title="临时关闭"></a>临时关闭</h3><p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200806233231.png" alt=""></p><h3 id="永久关闭"><a href="#永久关闭" class="headerlink" title="永久关闭"></a>永久关闭</h3><p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200806233244.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CENTOS7读取NTFS格式的移动硬盘和exFAT格式的U盘</title>
      <link href="/2020/08/06/CENTOS7%E8%AF%BB%E5%8F%96NTFS%E6%A0%BC%E5%BC%8F%E7%9A%84%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98%E5%92%8CexFAT%E6%A0%BC%E5%BC%8F%E7%9A%84U%E7%9B%98/"/>
      <url>/2020/08/06/CENTOS7%E8%AF%BB%E5%8F%96NTFS%E6%A0%BC%E5%BC%8F%E7%9A%84%E7%A7%BB%E5%8A%A8%E7%A1%AC%E7%9B%98%E5%92%8CexFAT%E6%A0%BC%E5%BC%8F%E7%9A%84U%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<h2 id="NTFS"><a href="#NTFS" class="headerlink" title="NTFS"></a>NTFS</h2><h3 id="更新阿里的yum源"><a href="#更新阿里的yum源" class="headerlink" title="更新阿里的yum源"></a>更新阿里的yum源</h3><p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200806232909.png" alt=""></p><h3 id="下载ntfs依赖"><a href="#下载ntfs依赖" class="headerlink" title="下载ntfs依赖"></a>下载ntfs依赖</h3><p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200806232923.png" alt=""></p><h2 id="exFat"><a href="#exFat" class="headerlink" title="exFat"></a>exFat</h2><h3 id="安装nux仓库"><a href="#安装nux仓库" class="headerlink" title="安装nux仓库"></a>安装nux仓库</h3><p><code>sudo yum install -y http://li.nux.ro/download/nux/dextop/el7/x86_64/nux-dextop-release-0-5.el7.nux.noarch.rpm</code></p><h3 id="安装exfat依赖"><a href="#安装exfat依赖" class="headerlink" title="安装exfat依赖"></a>安装exfat依赖</h3><p><code>sudo yum install exfat-utils fuse-exfat</code></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CENTOS7转文本文件为UTF-8格式</title>
      <link href="/2020/08/06/CENTOS7%E8%BD%AC%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E4%B8%BAUTF-8%E6%A0%BC%E5%BC%8F/"/>
      <url>/2020/08/06/CENTOS7%E8%BD%AC%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E4%B8%BAUTF-8%E6%A0%BC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>windows平台下的文本文件拷贝到centos7下打开乱码，可以通过enca工具修改为utf-8格式</p><ol><li><p>下载enca<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200806232358.png" alt=""></p></li><li><p>转换即可<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200806232419.png" alt=""></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Mac下Boost环境搭建</title>
      <link href="/2020/08/06/Mac%E4%B8%8BBoost%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/2020/08/06/Mac%E4%B8%8BBoost%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<p>Boost，一个功能强大、跨平台、开源而且免费的C++程序库，可以在其<a href="http://www.boost.org" target="_blank" rel="noopener">官网</a>了解更多。C++标准经过不断的升级完善，现在已经功能越来越吸引人了，Boost开发过程中也吸引了很多C++11新特性，从而更兼容C++的标准库了，这样，有什么理由不用它呢？虽然很多东西我们可以自己写，但是，借助功能稳定的库，可以提高生产力，节约程序员的时间，何乐不为？当然，并非让我们只是调用函数，传参数，完成任务就行了，如果不去了解下背后原理，那只能称之为码农，而不是程序员了。<br>由于开发环境基于Mac，那就基于它来搭建一个开发平台，来体验boost库的设计美妙和功能强大吧~：</p><ol><li><p>首先，需要下载boost的源码包，这里使用这个版本：boost_1_60_0.tar.bz2</p></li><li><p>解压，目录结构如下：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200806231652.png" alt=""><br>boos子目录下就是其源码了，它们按照功能划分，很清晰。</p></li><li><p>编译。编译器至少应支持C++98标准，这里使用gcc编译器，如下：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200806231726.png" alt=""></p></li><li><p>安装：<br>执行解压目录下文件进行配置：<code>./bootstrap.sh</code><br>执行<code>sudo ./b2 --buildtype=complete install</code>进行boost所有库的安装，在mac下安装后头文件路径为:/usr/local/include/boost，库路径为/usr/local/lib</p></li><li><p>构建工具安装<br>构建工具可以使用make、cmake等，这里使用boost自带的b2，它使用jamroot来配置、管理代码，然后每个模块子目录下都有jamfile。</p></li></ol><ul><li>cd tools/build</li><li>./booststrap.sh</li><li>sudo ./b2 install</li></ul><p>6.测试代码：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200806231928.png" alt=""></p><p>7.编译运行：<br>目录结构如下：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200806231952.png" alt=""><br>jamroot和jamfile文件内容分别如下：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200806232022.png" alt=""><br>jamroot说明了整个目录结构的编译规则，jamfile说明了文件的执行输出，如exe，unit-test等，现在需要测试main.cpp，进入te目录下执行b2命令即可，输出，执行后目录结构如下：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200806232053.png" alt=""><br>可以看到，在jamfile声明了unit-test，在执行b2命令时也进行了单元测试，这里默认生成debug版本的输出文件，如果要发布，执行”b2 release”即可。这里看到输出boost版本为106000，现在可以使用boost来进行开发了。<br>(也可以执行”g++ -o main.out main.cpp”，注意，在ubuntu下需要加上-Istdc++，即：g++ -o main.out main.cpp -Istdc++)</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> Boost </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Boost </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows安装配置ftp服务器</title>
      <link href="/2020/08/06/Windows%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEftp%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2020/08/06/Windows%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEftp%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<ol><li><p>在计算机管理的本地用户和组新建一个用来登录ftp服务器的用户:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200806230412.png" alt=""></p></li><li><p>在D盘新建一个测试目录ftp_upload:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200806230440.png" alt=""></p></li><li><p>添加Windows的FTP组件和IIS组件：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200806230508.png" alt=""></p></li><li><p>打开IIS管理平台，在网站那里右键，选择添加FTP站点，配置相关信息:</p></li><li><p>1 配置本地上传的物理路径：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200806230537.png" alt=""></p></li></ol><p>4.2 配置IP和SSL，这里不选择SSL先<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200806230558.png" alt=""></p><p>4.3 权限配置<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200806230619.png" alt=""></p><p>5.登录<br>在我的电脑输入如下链接，然后输入刚刚创建的账号linjk及其密码即可:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200806230644.png" alt=""></p><p>6.基于JAVA的ftp文件上传</p><blockquote><p>上面是使用图形界面的模式，下面基于java来配置使用</p></blockquote><p>6.1 添加maven依赖<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200806230739.png" alt=""></p><p>6.2 编写上传部分代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.linjk.Utils;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.apache.commons.net.ftp.FTPClient;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FtpClient</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ftp上传单个文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ftpUrl      ftp地址，ip即可，不需要ftp://前缀</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userName    ftp的用户名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> password    ftp的密码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> directory   上传至ftp的目录路径名，不包括ftp地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> srcFileName 要上传的文件全路径名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> destName    上传至ftp后存储的文件名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">upload</span><span class="params">(String ftpUrl,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 String userName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 String password,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 String directory,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 String srcFileName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 String destName)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FTPClient ftpClient = <span class="keyword">new</span> FTPClient();</span><br><span class="line">        FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ftpClient.connect(ftpUrl,<span class="number">21</span>); <span class="comment">// ftp端口默认为21</span></span><br><span class="line">            ftpClient.login(userName, password);</span><br><span class="line">            ftpClient.enterLocalPassiveMode();</span><br><span class="line">            File srcFile = <span class="keyword">new</span> File(srcFileName);</span><br><span class="line">            fis = <span class="keyword">new</span> FileInputStream(srcFile);</span><br><span class="line">            ftpClient.changeWorkingDirectory(directory); <span class="comment">// 设置上传目录</span></span><br><span class="line">            ftpClient.setBufferSize(<span class="number">1024</span>);</span><br><span class="line">            ftpClient.setControlEncoding(<span class="string">"gbk"</span>);</span><br><span class="line">            ftpClient.setFileType(FTPClient.BINARY_FILE_TYPE); <span class="comment">// 设置文件类型（二进制）</span></span><br><span class="line">            result = ftpClient.storeFile(destName, fis);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(FileNotFoundException e)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fis != <span class="keyword">null</span>) &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ftpClient.disconnect();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"关闭FTP连接发生异常！"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7.测试代码<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200806230904.png" alt=""></p><p>运行后，在刚刚配置的D盘的ftp_upload的linjk子目录下会有test.txt文件：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200806230924.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
          <category> ftp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ftp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Groovy初见(一)</title>
      <link href="/2020/08/05/Groovy%E5%88%9D%E8%A7%81(%E4%B8%80)/"/>
      <url>/2020/08/05/Groovy%E5%88%9D%E8%A7%81(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<p>Steps:</p><ol><li><a href="https://groovy.apache.org/download.html#distro" target="_blank" rel="noopener">Download Groovy</a></li><li>Configure Enviroment【GROOVY_HOME】<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200805210704.png" alt=""></li></ol><h3 id="groovysh"><a href="#groovysh" class="headerlink" title="groovysh"></a>groovysh</h3><p>类似node.js交互式功能界面，执行<code>groovysh</code>进入：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200805211036.png" alt=""><br>输入<code>?</code>可以查看帮助。</p><h3 id="groovyConsole"><a href="#groovyConsole" class="headerlink" title="groovyConsole"></a>groovyConsole</h3><p>命令行工具<code>groovy</code>:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200805211358.png" alt=""></p><h3 id="Sublime-Text构建"><a href="#Sublime-Text构建" class="headerlink" title="Sublime Text构建"></a>Sublime Text构建</h3><h4 id="新建groovy构建方式"><a href="#新建groovy构建方式" class="headerlink" title="新建groovy构建方式"></a>新建groovy构建方式</h4><p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200805212143.png" alt=""><br>输入如下命令并保存：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200805212236.png" alt=""><br>然后”Tool”-“Build System”就有groovy构建方式了，写一个测试groovy文件，然后按command+B，进行构建，输出如下：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200805212406.png" alt=""></p><p>###命令构建<br><code>groovy ${file}</code></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Groovy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Groovy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot源码分析之路(一)</title>
      <link href="/2020/07/30/SpringBoot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E8%B7%AF(%E4%B8%80)/"/>
      <url>/2020/07/30/SpringBoot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E8%B7%AF(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<h2 id="源码下载与初步构建"><a href="#源码下载与初步构建" class="headerlink" title="源码下载与初步构建"></a>源码下载与初步构建</h2><p><a href="https://github.com/spring-projects/spring-boot" target="_blank" rel="noopener">Springboot</a></p><p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200730212258.png" alt=""></p><p>下载完成后切换至v2.2.1.RELEASE的标签版本：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200730222108.png" alt=""></p><p>然后构建打包：</p><p><code>mvn clean package -Dmaven.test.skip=true -Pfast</code></p><p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200730222500.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue+Webpack发布微信公众号在iOS打开加载慢或返回时会出现空白界面需要刷新进入问题解决</title>
      <link href="/2020/07/28/Vue+Webpack%E5%8F%91%E5%B8%83%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%9C%A8iOS%E6%89%93%E5%BC%80%E5%8A%A0%E8%BD%BD%E6%85%A2%E6%88%96%E8%BF%94%E5%9B%9E%E6%97%B6%E4%BC%9A%E5%87%BA%E7%8E%B0%E7%A9%BA%E7%99%BD%E7%95%8C%E9%9D%A2%E9%9C%80%E8%A6%81%E5%88%B7%E6%96%B0%E8%BF%9B%E5%85%A5%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
      <url>/2020/07/28/Vue+Webpack%E5%8F%91%E5%B8%83%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E5%9C%A8iOS%E6%89%93%E5%BC%80%E5%8A%A0%E8%BD%BD%E6%85%A2%E6%88%96%E8%BF%94%E5%9B%9E%E6%97%B6%E4%BC%9A%E5%87%BA%E7%8E%B0%E7%A9%BA%E7%99%BD%E7%95%8C%E9%9D%A2%E9%9C%80%E8%A6%81%E5%88%B7%E6%96%B0%E8%BF%9B%E5%85%A5%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<p>使用Vue+Webpack开发微信公众号页面发布时，Android端打开就快很多，iOS端打开就很慢，登录进入主页后页面间切换偶尔会出现白屏，需要刷新才可以重新显示。调试会发现错误: can’t find variable: webpackjsonp，原来，Webpack在打包时用到的插件CommonsChunkPlugin会将相关文件分别打包成manifest、vendor和app三个js文件。</p><p>出现白屏估计是在iOS端的Webview加载时三个文件顺序不一样导致，而打开页面慢是因为manifest和vendor文件比app文件先加载。可注释解决，如下所示：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200728235439.png" alt=""></p><p>对比了js目录下，有这个区别：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200728235458.png" alt=""></p><p>在利用构建工具进行打包时，因为第三方引用模块代码通常很大，通常会将业务代码和第三方引用模块代码分开打包，从而利用浏览器的缓存区提高应用程序的首屏加载速度。</p><p>上面的CommonsChunkPlugin插件就是去抽取这些第三方的部分作为vendor.js独立打包，比较过打包后文件大小，未使用CommonsChunkPlugin的js目录大小会大两倍，文章标题出现的问题应该就是配置不对的问题，再好好了解下背后原理再试试先。</p>]]></content>
      
      
      <categories>
          
          <category> Frontend </category>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot切换内置Web容器</title>
      <link href="/2020/07/28/SpringBoot%E5%88%87%E6%8D%A2%E5%86%85%E7%BD%AEWeb%E5%AE%B9%E5%99%A8/"/>
      <url>/2020/07/28/SpringBoot%E5%88%87%E6%8D%A2%E5%86%85%E7%BD%AEWeb%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>Spring Boot默认的web容器为Tomcat，通过starter-web引入的，下面介绍如何替换默认的web容器：</p><ol><li><p>修改start-web排除tomcat的引入<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200728234733.png" alt=""></p></li><li><p>引入Jetty<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200728234744.png" alt=""></p></li></ol><p>正常启动如下：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200728234808.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac平台下python引用cv2错误处理</title>
      <link href="/2020/07/28/Mac%E5%B9%B3%E5%8F%B0%E4%B8%8Bpython%E5%BC%95%E7%94%A8cv2%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"/>
      <url>/2020/07/28/Mac%E5%B9%B3%E5%8F%B0%E4%B8%8Bpython%E5%BC%95%E7%94%A8cv2%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>在使用brew install opencv3后，进入python，引用cv2模块(试了几个都不行)出现如下错误:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200728234353.png" alt=""></p><p>看了一下/usr/local/lib/python2.7/site-packages路径下，有这样一个软链接：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200728234415.png" alt=""></p><p>说明cv2已经正确链接了，应该就是环境变量的配置了，修改”.bash_profile”配置文件：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200728234436.png" alt=""></p><p>现在可以了：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200728234454.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac下一个不错的Gif图片生成软件--GIPHY</title>
      <link href="/2020/07/28/Mac%E4%B8%8B%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%94%99%E7%9A%84Gif%E5%9B%BE%E7%89%87%E7%94%9F%E6%88%90%E8%BD%AF%E4%BB%B6-GIPHY/"/>
      <url>/2020/07/28/Mac%E4%B8%8B%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%94%99%E7%9A%84Gif%E5%9B%BE%E7%89%87%E7%94%9F%E6%88%90%E8%BD%AF%E4%BB%B6-GIPHY/</url>
      
        <content type="html"><![CDATA[<ol><li><p>APP Store搜索下载：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200728233904.png" alt=""></p></li><li><p>下载完安装后打开界面如下，它会显示一个取景框，我们可以把它移动到需要生成Gif区域并调整大小匹配区域，然后点击底部的红色即可开始录制：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200728233936.png" alt=""></p></li><li><p>这里录制一个片段后，程序界面如下，左下角就是录制的片段：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200728234002.png" alt=""></p></li><li><p>点击录制好的片段，弹出如下窗口:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200728234022.png" alt=""></p></li><li><p>点击”SAVE AS…”，格式选择”Gif”，然后自定义名字和选择保存路径即可</p></li><li><p>上传Gif并显示如下【额……这里显示不了~】:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200728234044.png" alt=""></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Mac </category>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenJDK12源码编译</title>
      <link href="/2020/07/23/OpenJDK12%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/"/>
      <url>/2020/07/23/OpenJDK12%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<p>使用Java不知不觉也有三年了，常听说会搞Jvm底层相关的才厉害，毕竟从C语言学起的娃，自然，还是想自己编译一个JDK试试……搞起来勒~</p><p>本次直接在Mac平台上开撸，首先，得安装些必要的依赖，当然，XCode工具套装，少不了的：<code>brew install autoconf &amp;&amp; brew install freetype &amp;&amp; brew install ccache</code></p><p>然后下载源码：<code>hg clone https://hg.openjdk.java.net/jdk/jdk12</code>，过程很漫长，互联网那么大，总有办法的，搞定后源码目录结构如下所示：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200723000245.png" alt=""></p><p>chmod u+x configure增加执行权限后，生成配置：<br><code>./configure --with-debug-level=slowdebug --enable-dtrace --with-jvm-variants=server --with-target-bits=64 --enable-ccache --with-num-cores=8 --with-memory-size=8000  --disable-warnings-as-errors</code></p><blockquote><p>说明：建议带上<strong>–disable-warnings-as-errors</strong>这个参数，否则编译过程中的warning也会中断编译的进程，实际上这些warning并不影响编译后的目标JDK的运行</p></blockquote><p><em>错误一：</em><br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200723000337.png" alt=""></p><p><em>解决：</em><br><code>sudo xcode-select --switch /Applications/Xcode.app/Contents/Developer</code></p><p><em>错误二：</em><br>再次生成配置，提示必须先安装配置OpenJDK11，因为OpenJDK由多个部分(HotSpot、JDK类库、JAXWS、JAXP等)构成，其中一部分(HotSpot)代码使用C、C++编写，而更多代码使用Java来实现，因此，编译就需要另外一个基础的JDK：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200723000514.png" alt=""></p><p><em>解决：</em><br>下载<a href="https://adoptopenjdk.net/archive.html?variant=openjdk11&jvmVariant=hotspot" target="_blank" rel="noopener">OpenJDK11</a>安装后，重新配置，成功：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200723001614.png" alt=""></p><p>最后，执行<code>make clean &amp;&amp; make images</code>进行编译：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200723002720.png" alt=""></p><p>嗯，喝杯咖啡☕️先咯，还是挺费CPU的……<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200723003943.png" alt=""></p><p>大约15分钟，搞定，MBP还是挺给力的：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200723004754.png" alt=""></p><p>看看构建生成了些啥玩意：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200723004918.png" alt=""></p><ul><li>buildtools: 用于生成、存放编译过程中用到的工具</li><li>hotspot: HotSpot虚拟机编译的中间文件</li><li>images: 使用make *-image产生的镜像存放的地儿</li><li>jdk: 编译后的jdk在这<del>~</del></li><li>support: 存放编译时产生的中间文件</li></ul><p>真的可以了？试下：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200723005156.png" alt=""><br>嗯，还算顺利，第一个可调试版本的HotSpot虚拟机出来了<del>那如何在IDE进行HotSpot源码调试了？搞起</del></p><p>这里使用CLion 2020.1这款IDE:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200723005344.png" alt=""></p><p>导入项目：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200723005445.png" alt=""></p><p>选择源码根目录后打开：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200723005536.png" alt=""><br>已经自动选好了需要导入的目录，直接点击”OK“即可：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200723010210.png" alt=""></p><p>增加调试，选择自己编译出来的java命令，增加参数，如“-version”或其他某个.class文件，并移除Build Before Launch，即可下断点了：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200723012346.png" alt=""></p><p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200723012537.png" alt=""></p><p>直接Resume Programme会如下输出：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200723013331.png" alt=""></p><p>发现三次中断后才输出版本号，这是LLDB执行异常，可以在断点进入如上Java.c的源码时，切换到调试面板的LLDB执行如下命令：<br><code>process handle --pass true --stop false SIGSEGV</code>和<code>process handle --pass true --stop false SIGBUS</code>，再次调试就直接输出了：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200723013720.png" alt=""></p><p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200723013755.png" alt=""></p><p>这种方式不能直接在IDE构建出jdk包，会提示很多文件找不到，需要修改CMakeLists.txt文件，目前还不知道怎么搞，后面知道到再补充了。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> OpenJDK </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenJDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eigen使用</title>
      <link href="/2020/07/21/Eigen%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/07/21/Eigen%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><a href="http://eigen.tuxfamily.org/index.php?title=Main_Page#Overview" target="_blank" rel="noopener">Eigen</a>是一个不错的针对线性代数的C++库，它可以高效处理矩阵、向量、数值分析，在官网可以看到更详细的介绍:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200721003204.png" alt=""></p><p>用这个库，之前很多写的类似的代码都可以更精简、高效。</p><p>这里下载稳定版本的3.3.3，下载后解压到一个目录下，如下:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200721003230.png" alt=""></p><p>下面开始测试调用它的头文件来使用下:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200721003256.png" alt=""></p><p>这里创建了一个2*2的矩形，并输出它。</p><p>编译：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200721003317.png" alt=""></p><p>注意，这里需要使用”-I”参数来指定头文件的查找目录，使用Eigen很简单，只需要下载tgz包，不需要编译安装任何东西，在目录下的”Eigen”子目录就是使用Eigen编译时所需要的文件，这些文件在所有系统平台都是一样的。</p><p>编译完后，目录如下：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200721003339.png" alt=""></p><p>当前用户默认拥有执行权限，执行结果如下：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200721003359.png" alt=""></p><p>现在在C++使用矩形运行就不需要再编写很多代码了。更多的使用参考<a href="http://eigen.tuxfamily.org/dox/" target="_blank" rel="noopener">官方帮助</a>文档就可以做很多东西了。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> Eigen </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Eigen </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker配置非root用户执行客户端命令</title>
      <link href="/2020/07/21/Docker%E9%85%8D%E7%BD%AE%E9%9D%9Eroot%E7%94%A8%E6%88%B7%E6%89%A7%E8%A1%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%91%BD%E4%BB%A4/"/>
      <url>/2020/07/21/Docker%E9%85%8D%E7%BD%AE%E9%9D%9Eroot%E7%94%A8%E6%88%B7%E6%89%A7%E8%A1%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>在执行Docker客户端命令时，因为涉及一些系统根目录的操作，因此，需要切换到root用户权限执行，但是这样权限管理就难处理了，可以配置非root用户也可以执行docker客户端命令，步骤如下：</p><ol><li><p>创建docker组<br><code>sudo groupadd docker</code></p></li><li><p>当前登录用户加入到新建的docker组<br><code>sudo gpasswd -a ${USER} docker</code></p></li><li><p>重启docker服务<br><code>sudo systemctl restart docker</code></p></li><li><p>当前用户<strong>重新登录</strong>即可执行docker ps等命令了。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker镜像导出与导入</title>
      <link href="/2020/07/21/Docker%E9%95%9C%E5%83%8F%E5%AF%BC%E5%87%BA%E4%B8%8E%E5%AF%BC%E5%85%A5/"/>
      <url>/2020/07/21/Docker%E9%95%9C%E5%83%8F%E5%AF%BC%E5%87%BA%E4%B8%8E%E5%AF%BC%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<p>在拉取Docker镜像时，有时会很慢，这时，可以在其它电脑已下载好的导出，然后复制过来导入即可。</p><p>导出镜像：</p><p><code>docker save -o &lt;image_name&gt;.tar &lt;image_name&gt;:&lt;tag&gt;</code></p><p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200721000619.png" alt=""></p><p>导入镜像：</p><p><code>docker load --input &lt;image_name&gt;.tar    或    docker load &lt; &lt;docker_name&gt;.tar</code></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TMS开发组件包-TAdvStringGrid表格控件</title>
      <link href="/2020/07/20/TMS%E5%BC%80%E5%8F%91%E7%BB%84%E4%BB%B6%E5%8C%85-TAdvStringGrid%E8%A1%A8%E6%A0%BC%E6%8E%A7%E4%BB%B6/"/>
      <url>/2020/07/20/TMS%E5%BC%80%E5%8F%91%E7%BB%84%E4%BB%B6%E5%8C%85-TAdvStringGrid%E8%A1%A8%E6%A0%BC%E6%8E%A7%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>最近项目涉及一些复杂表格显示的实现，尝试使用Dev Express的cxGrid控件多次还是没法实现想要的效果，后来发现，<a href="https://www.tmssoftware.com/site/products.asp?t=vclp" target="_blank" rel="noopener">TMS</a>开发组件包的TAdvStringGrid可以实现效果。这里举例来说明一下，例如，需要实现如下效果:</p><p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200720232036.png" alt=""></p><p>  如上所示是一个3行4列的表格，其中，第一行的1、2列合并，第2行的2、3列合并，下面使用TAdvStringGrid来实现，步骤如下：</p><ul><li><p>新建一个VCL窗口项目，布局界面</p><p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200720232123.png" alt=""></p><p>添加TAdvStringGrid控件，默认它是一个5列10行的空白表格，这里需要自定义数据，这里修改它的ColCount和RowCount属性为0，但是，默认还是一个1列1行的空白表格，这里可以不用理会。</p><p>按钮”显示数据”点击后，就显示如上效果的表格。</p></li><li><p>实现如上Excel表格展示效果</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">TForm1</span>.<span class="title">btn1Click</span><span class="params">(Sender: TObject)</span>;</span></span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">        count: Integer;</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  AdvStringGrid1.ColCount := <span class="number">0</span>;</span><br><span class="line">  AdvStringGrid1.RowCount := <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 初始化行列 (3行4列)</span></span><br><span class="line">  <span class="keyword">for</span> count := <span class="number">0</span> <span class="keyword">to</span> <span class="number">1</span> <span class="keyword">do</span>              <span class="comment">// 因为第一行是表格头，因此就2行，从0开始数，所以为2-1=1，行与列一样的道理。</span></span><br><span class="line">  <span class="keyword">begin</span></span><br><span class="line">      AdvStringGrid1.AddRow;</span><br><span class="line">  <span class="keyword">end</span>;</span><br><span class="line">  <span class="keyword">for</span> count := <span class="number">0</span> <span class="keyword">to</span> <span class="number">2</span> <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">begin</span></span><br><span class="line">      AdvStringGrid1.AddColumn;</span><br><span class="line">  <span class="keyword">end</span>;</span><br><span class="line"> </span><br><span class="line">  AdvStringGrid1.MergeCells(<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">  AdvStringGrid1.Cells[<span class="number">0</span>, <span class="number">0</span>] := <span class="string">'1'</span>;</span><br><span class="line">  AdvStringGrid1.Cells[<span class="number">2</span>, <span class="number">0</span>] := <span class="string">'2'</span>;</span><br><span class="line">  AdvStringGrid1.Cells[<span class="number">3</span>, <span class="number">0</span>] := <span class="string">'3'</span>;</span><br><span class="line"> </span><br><span class="line">  AdvStringGrid1.MergeCells(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">  AdvStringGrid1.Cells[<span class="number">0</span>, <span class="number">1</span>] := <span class="string">'4'</span>;</span><br><span class="line">  AdvStringGrid1.Cells[<span class="number">1</span>, <span class="number">1</span>] := <span class="string">'5'</span>;</span><br><span class="line">  AdvStringGrid1.Cells[<span class="number">3</span>, <span class="number">1</span>] := <span class="string">'6'</span>;</span><br><span class="line"> </span><br><span class="line">  AdvStringGrid1.Cells[<span class="number">0</span>, <span class="number">2</span>] := <span class="string">'7'</span>;</span><br><span class="line">  AdvStringGrid1.Cells[<span class="number">1</span>, <span class="number">2</span>] := <span class="string">'8'</span>;</span><br><span class="line">  AdvStringGrid1.Cells[<span class="number">2</span>, <span class="number">2</span>] := <span class="string">'9'</span>;</span><br><span class="line">  AdvStringGrid1.Cells[<span class="number">3</span>, <span class="number">2</span>] := <span class="string">'10'</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><p>运行如下:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200720232345.png" alt=""></p><p>效果实现，其他的TMS组件可以自己再尝试使用即可。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
          <category> Delphi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Delphi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TcxCurrencyEdit无法输入小数问题解决</title>
      <link href="/2020/07/20/TcxCurrencyEdit%E6%97%A0%E6%B3%95%E8%BE%93%E5%85%A5%E5%B0%8F%E6%95%B0%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
      <url>/2020/07/20/TcxCurrencyEdit%E6%97%A0%E6%B3%95%E8%BE%93%E5%85%A5%E5%B0%8F%E6%95%B0%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<p>最近在使用TcxCurrencyEdit控件时，发现配置了指定输入小数位数，却无法输入小数的问题：</p><p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200720231412.png" alt=""></p><p><strong>解决方法</strong>：</p><blockquote><p>“控制面板” - “时间和区域” - “区域” - “更改日期、时间或数字格式”<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200720231506.png" alt=""><br>修改货币tab栏的小数位数为2或其他实际需要的位数即可:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200720231526.png" alt=""></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Windows </category>
          
          <category> Delphi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Delphi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring源码环境搭建_idea</title>
      <link href="/2020/07/20/Spring%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-idea/"/>
      <url>/2020/07/20/Spring%E6%BA%90%E7%A0%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-idea/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前提条件：安装Git和Gradle(也可以使用源码包里配置的版本，推荐使用自己安装的，方便执行命令)</p></blockquote><h2 id="源码下载-git-clone-git-github-com-SpringSource-Spring-framework-git"><a href="#源码下载-git-clone-git-github-com-SpringSource-Spring-framework-git" class="headerlink" title="[源码下载](git clone git://github.com/SpringSource/Spring-framework.git)"></a>[源码下载](git clone git://github.com/SpringSource/Spring-framework.git)</h2><p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200720221952.png" alt=""></p><h2 id="导入IDEA"><a href="#导入IDEA" class="headerlink" title="导入IDEA"></a>导入IDEA</h2><p>查看开源代码，首先是看它的README.md文件，它会告诉我们很多东西，这里可以看到，如果要导入IDEA集成开发环境，需要去看哪个文件操作:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200720222053.png" alt=""></p><p>打开文件”import-into-idea.md”可以看到如下几步：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200720222142.png" alt=""></p><p>按照提示的步骤即可导入:</p><ul><li>执行命令<code>./gradlew :spring-oxm:compileTestJava</code>，结果如下：</li></ul><p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200720223803.png" alt=""></p><ul><li>导入IntelliJ IDEA（File-&gt;New-&gt;Project from existing Sources-&gt;Navigate to directory-&gt;Select build.gradle）</li></ul><p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200720223915.png" alt=""></p><ul><li>点击【Open】等待下载依赖导入:</li></ul><p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200720224027.png" alt=""></p><p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200720230250.png" alt=""></p><ul><li>测试构建模块Spring-aop:</li></ul><p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200720230323.png" alt=""></p><p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200720230508.png" alt=""></p><p>好了，Spring源码环境搭建好了，有时间的话可以慢慢了解下Spring的关键技术如何实现了，努力做到知其所以然~</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++编译OpenCV生成动态库问题解决</title>
      <link href="/2020/07/18/C++%E7%BC%96%E8%AF%91OpenCV%E7%94%9F%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
      <url>/2020/07/18/C++%E7%BC%96%E8%AF%91OpenCV%E7%94%9F%E6%88%90%E5%8A%A8%E6%80%81%E5%BA%93%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<p>1.包含&lt;opencv2/objdectect/objdetect.hpp&gt;, 声明了CascadeClassifier变量后，工程如下:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200721002411.png" alt=""></p><p>执行make命令后发生如下错误：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200721002435.png" alt=""></p><p>解决，增加Lib链接，如下：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200721002503.png" alt=""><br>再次make，可以了。</p><p>2.增加imread函数调用后，发生如下错误:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200721002555.png" alt=""></p><p>makefile需要增加如下链接(-lopencv_imgcodes):<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200721002640.png" alt=""></p><p>python调用人脸检测后，成功识别出两个人脸:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200721002703.png" alt=""></p><p>3.上面是在mac上运行的，把so库拿到centos上运行时，报如下错误:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200721002746.png" alt=""></p><p>在用户加目录的.bashrc增加如下这行(永久生效)或直接命令行执行(临时生效)，即可:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200721002805.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> OpenCV </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ANTLR(一)</title>
      <link href="/2020/07/15/ANTLR(%E4%B8%80)/"/>
      <url>/2020/07/15/ANTLR(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.antlr.org" target="_blank" rel="noopener">ANTLR</a>是基于Java编写的，一款强大的语法分析器生成工具，可用于读取、处理、执行和翻译结构化文本或二进制文件。除了间接左递归，ANTLR 4几乎能处理任何语法。</p><h2 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h2><p>安装很简单，下载最新jar包即可，该jar包包含了运行ANTLR的工具和编译、执行ANTLR产生的识别程序所依赖的全部运行库，即ANTLR工具将语法文件转换成可以识别该语法文件所描述的语言的程序。</p><p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200715220716.png" alt=""></p><p>下载好后，还需配置CLASSPATH使得Java程序能找到ANTLR工具和运行库:<code>export CLASSPATH=&quot;.:/Users/linjk/Documents/usr/services/antlr-4.8-complete.jar:$CLASSPATH&quot;</code></p><p>在shell的rc文件配置别名，方便启动：<code>alias antlr4=&#39;java -jar /Users/linjk/Documents/usr/services/antlr-4.8-complete.jar&#39;</code>，配置调试工具: <code>alias grun=&#39;java org.antlr.v4.gui.TestRig&#39;</code></p><p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200715220953.png" alt=""></p><p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200715221051.png" alt=""></p><h2 id="入门体验"><a href="#入门体验" class="headerlink" title="入门体验"></a>入门体验</h2><p>为了简单，定义一个能识别类似hello world或hello jim的词组的语法：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200715221847.png" alt=""></p><p>接下来编译该语法文件：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200715222023.png" alt=""><br>提示不匹配，语法名字和文件名字应一致，修改一致后：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200715222204.png" alt=""></p><p>它生成了antlrHelloParser.java和antlrHelloLexer.java组成的、可以运行的语法识别程序。(这里还缺少一个main程序来触发语言识别过程)</p><p>然后编译生成class文件<code>javac -g *.java</code>，<code>grun antlrHello r -tokens</code>来运行：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200715223921.png" alt=""><br>运行后，输入hello world，然后ctrl+d来输入文件结束符，因为使用了选项<code>-r tokens</code>，所以上面打印出来全部的词法符号的列表。还可以导出语法分析树：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200715224424.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
          <category> ANTLR </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ANTLR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenResty(二)-Nginx和Lua基础</title>
      <link href="/2020/07/09/OpenResty(%E4%BA%8C)-Nginx%E5%92%8CLua%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/07/09/OpenResty(%E4%BA%8C)-Nginx%E5%92%8CLua%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><blockquote><p><a href="http://nginx.org/en/docs/" target="_blank" rel="noopener">Nginx模块配置文档</a></p></blockquote><ul><li>能通过Lua代码解决的，<strong>不用</strong>Nginx的配置、变量和模块解决</li><li>Nginx支持的功能，OpenResty不一定支持，需要看版本号，它们的版本号保持一致的</li></ul><h3 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h3><pre class="mermaid">graph LR    Master进程 --> Worker进程1     subgraph 客户端连接        客户端1 --> Worker进程1        客户端2 --> Worker进程1    end    Master进程 --> Worker进程2    Master进程 --> Worker进程...    Master进程 --> Worker进程n</pre><p>Master进程不负责处理终端的请求，它只管理Worker进程，主要是接受管理员发送的信号量、监控Worker的运行状态。<br>Worker进程从Master进程<strong>fork</strong>出来的，彼此之间相互独立，互不影响。有多个worker进程时，其中一个Worker进程奔溃退出了，并不会影响其他Worker进程。</p><p>Nginx和OpenResty的<a href="https://github.com/openresty/lua-nginx-module#readme" target="_blank" rel="noopener">生命周期关系</a>：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200710002937.png" alt=""></p><h2 id="Lua"><a href="#Lua" class="headerlink" title="Lua"></a>Lua</h2>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> OpenResty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenResty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker安装MariaDB</title>
      <link href="/2020/07/08/Docker%E5%AE%89%E8%A3%85MariaDB/"/>
      <url>/2020/07/08/Docker%E5%AE%89%E8%A3%85MariaDB/</url>
      
        <content type="html"><![CDATA[<p>MariaDb在官网的Mac系统的pkg包居然是10.2版本的，最新都10.5.4了，只能在docker仓库里查找一下是否有官方包了:<code>docker search mariadb</code>，有，很好，下载最新版本: <code>docker pull mariadb:10.5.4</code></p><p>查看本地已有的所有镜像确认一下：<code>docker images</code>:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200709003233.png" alt=""></p><p>运行数据库前，首先创建数据目录:<br><code>mkdir -p /Users/linjk/Documents/docker/mariadb/data</code> </p><p>启动数据库服务: <code>docker run --name mariadb -p 3298:3306 -e MYSQL_ROOT_PASSWORD={root用户密码} -v /Users/linjk/Documents/docker/mariadb/data:/var/lib/mysql -d mariadb:10.5.4</code>，参数说明</p><table><thead><tr><th>参数名</th><th>参数说明</th></tr></thead><tbody><tr><td>–name</td><td>运行的容器的名称</td></tr><tr><td>-p</td><td>主机端口：容器端口的映射关系</td></tr><tr><td>-e</td><td>设置数据库root用户的密码</td></tr><tr><td>-v</td><td>数据卷映射</td></tr><tr><td>-d</td><td>后台运行容器的模式</td></tr></tbody></table><p>查看容器是否运行<code>docker ps -a</code>:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200709003808.png" alt=""></p><blockquote><p>如果需要容器在运行docker服务后自启动，可以配置：<code>docker container update --restart=always {容器id}</code><br>如果需要进入容器查看数据库更多信息，可以配置：<code>docker exec -it {容器Id} bash</code>，然后执行命令<code>mysql -uroot -proot密码</code>即可在容器内登录数据库。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> DB </category>
          
          <category> MariaDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MariaDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenResty(一)-入门</title>
      <link href="/2020/07/06/OpenResty(%E4%B8%80)-%E5%85%A5%E9%97%A8/"/>
      <url>/2020/07/06/OpenResty(%E4%B8%80)-%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/openresty/openresty.org" target="_blank" rel="noopener">OpenResty</a>诞生于2007年，是一个兼具开发效率和性能的服务端开发平台，其核心是基于Nginx的一个C模块(lua-nginx-module)，该模块将LuaJIT嵌入到Nginx服务器中，并对外提供了一套完整的Lua API，透明地支持非阻塞I/O，提供了轻量级线程、定时器等高级抽象。主要用来实现微服务API网关。</p><pre class="mermaid">graph LR;    OpenResty三大特性-->详尽的文档和测试用例;    OpenResty三大特性-->同步非阻塞;    OpenResty三大特性-->动态;</pre><blockquote><p>对于 OpenResty 来说，绝大部分都是同步操作，只有 ngx.timer 这种后台定时器相关的 API，才是异步操作</p></blockquote><h3 id="安装OpenResty"><a href="#安装OpenResty" class="headerlink" title="安装OpenResty"></a>安装OpenResty</h3><p><code>brew tap openresty/brew &amp;&amp; brew install openresty</code></p><blockquote><p>小插曲：<br>brew命令卡在<strong>Updating Homebrew…</strong><br>可以<code>Ctrl+C</code>取消下就可以了<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200707222135.png" alt="brew慢问题懒人解决方式"></p></blockquote><p>OK, 安装成功：<br><code>which resty &amp;&amp; resty -e &quot;ngx.say(&#39;【OpenResty】&#39;)&quot;</code></p><p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200707230630.png" alt="OpenResty安装成功"></p><p>安装信息：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200708002135.png" alt=""></p><blockquote><p>–prefix就是安装路径了</p></blockquote><h3 id="雏形"><a href="#雏形" class="headerlink" title="雏形"></a>雏形</h3><p>上面直接通过命令行的-e参数运行nginx服务的，现在，正式一点，在文件夹下通过配置文件配置方式，更接近实际：</p><p><a href="https://github.com/openresty/lua-nginx-module#content_by_lua_file" target="_blank" rel="noopener">更详细API参考</a></p><ul><li>准备目录结构</li></ul><p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200707231028.png" alt="目录"></p><ul><li>准备配置文件</li></ul><p><code>vim demo/conf/nginx.conf</code></p><p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200707231257.png" alt="nginx.conf"></p><ul><li>启动OpenResty服务</li></ul><p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200707231410.png" alt="OpenResty服务"><br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200707231446.png" alt="访问测试"></p><ul><li>退出服务</li></ul><p><code>openresty -p</code>pwd<code>-c demo/conf/nginx.conf -s quit</code></p><p>上面直接把代码放在配置文件，不合适，现在把它抽出来：</p><p><code>mkdir demo/lua &amp;&amp; echo &quot;ngx.say(&#39;openresty&#39;)&quot; &gt; demo/lua/openresty.lua &amp;&amp; cat demo/lua/openresty.lua</code></p><p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200708001505.png" alt=""></p><p>然后修改配置文件nginx.conf:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200708001638.png" alt=""></p><p>重启OpenResty服务，可以正常访问。</p><h3 id="寻求帮助"><a href="#寻求帮助" class="headerlink" title="寻求帮助"></a>寻求帮助</h3><p>可以借助OpenResty提供的命令<code>restydoc</code>，如：</p><blockquote><p>restydoc -s ngx.say<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200708002431.png" alt=""><br>这些文档的路径就是–prefix参数下的pod子文件夹</p></blockquote><h3 id="包管理工具"><a href="#包管理工具" class="headerlink" title="包管理工具"></a>包管理工具</h3><p><a href="http://opm.openresty.org" target="_blank" rel="noopener">OPM</a>是OpenResty自带的包管理器(<em>不支持私有包</em>)，类似docker search，opm也支持搜索:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200708003326.png" alt=""></p><p><a href="https://github.com/bungle/awesome-resty" target="_blank" rel="noopener">这里</a>维护了几乎所有OpenResty可用的包。</p><p><a href="https://luarocks.org" target="_blank" rel="noopener">luarockers</a>是推荐使用的包管理工具，安装步骤：</p><ul><li><p>wget <a href="https://luarocks.org/releases/luarocks-3.3.1.tar.gz" target="_blank" rel="noopener">https://luarocks.org/releases/luarocks-3.3.1.tar.gz</a></p></li><li><p>tar zxf luarocks-3.3.1.tar.gz</p></li><li><p>【需事先安装lua】cd luarocks-3.3.1 &amp;&amp; ./configure &amp;&amp; make &amp;&amp; sudo make install</p></li></ul><p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200708004213.png" alt=""></p><h3 id="OPM项目初探"><a href="#OPM项目初探" class="headerlink" title="OPM项目初探"></a>OPM项目初探</h3><p>通过官方的<a href="https://github.com/openresty/opm" target="_blank" rel="noopener">OPM项目</a>，了解OpenResty的基本开发的目录结构，有助于入门。透过这个项目，可以学习一个OpenResty项目是如何分层组织起来的。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> OpenResty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenResty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AboutMe</title>
      <link href="/2020/07/05/AboutMe/"/>
      <url>/2020/07/05/AboutMe/</url>
      
        <content type="html"><![CDATA[<p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/wechat.jpg" alt="微信公众号【时光记旅】"></p>]]></content>
      
      
      <categories>
          
          <category> Misc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS多线程笔记</title>
      <link href="/2017/02/04/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
      <url>/2017/02/04/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>在iOS开发中，有三种多线程处理方式：</p><ol><li>利用NSThread</li><li>NSOperation和NSOperationQueue</li><li>利用GCD(Grand Central Dispatch)</li></ol><p>使用上，从1到3是越来越简单，但是，对于1和2还是需要了解一下，了解本质有利于在出现一些bug时思考得更深入一些。</p><h2 id="NSThread"><a href="#NSThread" class="headerlink" title="NSThread"></a>NSThread</h2><p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200905113151.png" alt=""></p><p>iOS和Android一样，只能在UI线程更新UI界面，如果在子线程需要更新UI控件，需要执行[self performSelctrorOnMainThread: withObject: waitUntilDone:]来进行更新操作。</p><p>第一次运行输出如下：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200905113228.png" alt=""></p><p>第二次运行输出如下：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200905113241.png" alt=""></p><p>可以看到，虽然启动了线程，但是不是一启动就进入执行状态，CPU会在线程之间切换执行，线程就会在运行、就绪状态间切换，如需调用start函数后(此时线程处于就绪态)马上切换到运行态，可在主线程调用此函数: [NSThread sleepForTimeInterval:0.001]让线程休眠一下，进入阻塞状态，然后等待CPU调度，如果想让线程有更多的运行机会，可以调整优先级，默认优先级为0.5:<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200905113307.png" alt=""></p><p>结果如下：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200905113328.png" alt=""></p><p>在子线程出现如下情况会自行终止：</p><ol><li>线程逻辑函数处理完成</li><li>线程执行中发生异常</li><li>调用了[NSThread exit]</li></ol><p>注意：主线程结束后，由主线程启动的子线程不会跟随终止，可以如下在UI线程终止子线程，利用发生cancle信号:</p><p>程序和运行结果如下：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200905113414.png" alt=""></p><p><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200905113427.png" alt=""></p><p>这里设定500毫秒后发送终止子线程信号，子线程判断收到cancel信号后终止自己。</p><h2 id="NSOperation和NSOperationQueue"><a href="#NSOperation和NSOperationQueue" class="headerlink" title="NSOperation和NSOperationQueue"></a>NSOperation和NSOperationQueue</h2><p>NSOperationQueue是一个<strong>FIFO队列</strong>，负责管理系统提交的多个NSOperation。</p><p>NSOperation类型Java里的Runnable接口，代表一个多线程任务，它有NSInvocationOperation和NSBlockOperation两个子类(用于封装需要异步执行的任务)，这两个子类可以直接使用，或者开发者可以自己继承NSOperation来实现自己的子类。</p><p>开发步骤：</p><ol><li>创建NSOperationQueue队列，设置其属性</li><li>创建NSOperation子类的对象，然后将对象提交到NSOperationQueue队列，队列将按顺序依次启动每个NSOperaion。</li></ol><p>示例：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200905113533.png" alt=""></p><p>可以看到，这里开启了两个线程来处理任务。</p><h2 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h2><p>核心概念：</p><ol><li>队列：在底层维护一个线程池，使用FIFO方式管理开发者提交的任务，有串行队列和并发队列</li><li>任务：开发者提交给队列的工作单元，这些任务会交由队列底层的线程池内执行</li></ol><p>开发步骤：</p><ol><li>创建队列</li><li>将任务提交给队列</li></ol><p>示例：<br><img src="https://gitee.com/linjk/linjkImgs/raw/master/imgs/20200905113625.png" alt=""></p><p>这里创建了一个串行队列和一个并发队列并且都以异步方式提交任务。在输出中可以发现，在串行队列中，会先后执行代码块，而在并发队列中，会并发执行代码块。</p><p>另外，还有dispatch_once可以让代码只运行一次，通常用于单例模式，dispatch_apply可以让代码重复运行多次，这里就不进行测试了。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
